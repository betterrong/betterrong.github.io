[{"categories":["uxti"],"content":"给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 注意空字符串可被认为是有效字符串。 示例 1: 输入: \"()\" 输出: true 示例 2: 输入: \"()[]{}\" 输出: true 示例 3: 输入: \"(]\" 输出: false 示例 4: 输入: \"([)]\" 输出: false 示例 5: 输入: \"{[]}\" 输出: true Solution: bool isValid(char* s) { //想法 数组模拟堆栈 int len = 0; len = strlen(s); char *stack = (char *) malloc (sizeof(char) * len); // j = 栈顶+1 int i = 0, j = 0; while (*(s + i) != '\\0') { //第一个字符是 ')}]' ，有多余的 ')}]' 则返回false if ((*(s + i) == ')' || *(s + i) == '}' || *(s + i) == ']' )\u0026\u0026 j == 0) { return false; //如果字符是 '({[' 则入栈 } else if (*(s + i) == '(' || *(s + i) == '{' || *(s + i) == '[') { *(stack + j) = *(s + i); i++; j++; //字符是 ')}]' } else { if (*(s + i) == ')' \u0026\u0026 *(stack + j - 1) != '(') { return false; } if (*(s + i) == '}' \u0026\u0026 *(stack + j - 1) != '{') { return false; } if (*(s + i) == ']' \u0026\u0026 *(stack + j - 1) != '[') { return false; } i++; //配对成功，出栈 j--; } } if (j == 0) { return true; } else { return false; } } func isValid(s string) bool { if s == \"\" { return true } if len(s)%2 != 0 { return false } var stack []byte for i := 0; i \u003c len(s); i++ { if s[i] == '(' || s[i] == '{' || s[i] == '[' { stack = append(stack, s[i]) } else { if len(stack) == 0 { return false } topChar := stack[len(stack)-1] stack = stack[:len(stack)-1] if s[i] != ')' \u0026\u0026 topChar == '(' { return false } if s[i] != '}' \u0026\u0026 topChar == '{' { return false } if s[i] != ']' \u0026\u0026 topChar == '[' { return false } } } return len(stack) == 0 } 20. 有效的括号 ","date":"2020-07-26","objectID":"https://betterrong.github.io/leetcode-20/:0:0","tags":["leetcode","c","go"],"title":"leetcode 20. 有效的括号","uri":"https://betterrong.github.io/leetcode-20/"},{"categories":["uxti"],"content":"忏悔 昨天没有做 leetcode ，我在此进行深深地忏悔。 再难也不能放弃啊！ 编写一个函数来查找字符串数组中的最长公共前缀。 如果不存在公共前缀，返回空字符串 \"\"。 示例 1: 输入: [\"flower\",\"flow\",\"flight\"] 输出: \"fl\" 示例 2: 输入: [\"dog\",\"racecar\",\"car\"] 输出: \"\" 解释: 输入不存在公共前缀。 说明: 所有输入只包含小写字母 a-z 。 Solution: char* longestCommonPrefix(char** strs, int strsSize) { if(strsSize==0) return \"\"; for (int col = 0; col \u003c strlen(strs[0]); col++) { for (int row = 0; row \u003c strsSize; row++) { if (strs[row][col] != strs[0][col]) { strs[0][col] = '\\0'; break; } } } return strs[0]; } func longestCommonPrefcolx(strs []strcolng) strcolng { if len(strs) == 0 { return \"\" } for col := 0; col \u003c len(strs[0]); col++ { for row := 1; row \u003c len(strs); row++ { if col == len(strs[row]) || strs[row][col] != strs[0][col] { return strs[0][:col] } } } return strs[0] } ","date":"2020-07-23","objectID":"https://betterrong.github.io/leetcode-14/:0:0","tags":["leetcode","c","go"],"title":"leetcode 14 最长公共前缀","uri":"https://betterrong.github.io/leetcode-14/"},{"categories":["uxti"],"content":"罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。 字符 数值 I 1 V 5 X 10 L 50 C 100 D 500 M 1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。 X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。 给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。 示例 1: 输入: \"III\" 输出: 3 示例 2: 输入: \"IV\" 输出: 4 示例 3: 输入: \"IX\" 输出: 9 示例 4: 输入: \"LVIII\" 输出: 58 解释: L = 50, V= 5, III = 3. 示例 5: 输入: \"MCMXCIV\" 输出: 1994 解释: M = 1000, CM = 900, XC = 90, IV = 4. Solution: int romanToInt(char* s) { int num = 0; char Roman_numbers[7] = {'I', 'V', 'X', 'L', 'C', 'D', 'M'}; for (int i = 0; i \u003c strlen(s); i++) { if (s[i] == 'I') { if (s[i + 1] == 'V' || s[i + 1] == 'X') { num -= 1; } else { num++; } } if (s[i] == 'X') { if (s[i + 1] == 'L' || s[i + 1] == 'C') { num -= 10; } else { num += 10; } } if (s[i] == 'C') { if (s[i + 1] == 'D' || s[i + 1] == 'M') { num -= 100; } else { num += 100; } } if (s[i] == 'V') num += 5; if (s[i] == 'L') num += 50; if (s[i] == 'D') num += 500; if (s[i] == 'M') num += 1000; } return num; } //使用 map 存储字符和数字的对应关系，将字符串从右向左读，如果新的字符比原来的大，则加上，若比原来的小则减去。 func romanToInt(s string) int { m := map[byte]int{ 'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000, } n := m[s[len(s) - 1]] for i := len(s) - 1; i \u003e 0; i-- { preNum := m[s[i-1]] if m[s[i]] \u003e preNum { n -= preNum }else { n += preNum } } return n } https://leetcode-cn.com/problems/roman-to-integer/ ","date":"2020-07-22","objectID":"https://betterrong.github.io/leetcode-13/:0:0","tags":["leetcode","c","go"],"title":"leetcode 13. 罗马数字转整数","uri":"https://betterrong.github.io/leetcode-13/"},{"categories":["vetgjilu"],"content":"本文记录 VuePress 的搭建以及配置过程。","date":"2020-07-21","objectID":"https://betterrong.github.io/how-to-use-vuepress/","tags":["文档书写","vuepress"],"title":"如何使用 VuePress 写文档","uri":"https://betterrong.github.io/how-to-use-vuepress/"},{"categories":["vetgjilu"],"content":"0x00 简介 VuePress 由两部分组成：第一部分是一个极简静态网站生成器，它包含由 Vue 驱动的主题系统和插件 API，另一个部分是为书写技术文档而优化的默认主题，它的诞生初衷是为了支持 Vue 及其子项目的文档需求。 每一个由 VuePress 生成的页面都带有预渲染好的 HTML，也因此具有非常好的加载性能和搜索引擎优化（SEO）。同时，一旦页面被加载，Vue 将接管这些静态内容，并将其转换成一个完整的单页应用（SPA），其他的页面则会只在用户浏览到的时候才按需加载。 我目前配制好的笔记如下： UTt8hQ.png \" UTt3tg.png \" ","date":"2020-07-21","objectID":"https://betterrong.github.io/how-to-use-vuepress/:1:0","tags":["文档书写","vuepress"],"title":"如何使用 VuePress 写文档","uri":"https://betterrong.github.io/how-to-use-vuepress/"},{"categories":["vetgjilu"],"content":"0x01 准备 ","date":"2020-07-21","objectID":"https://betterrong.github.io/how-to-use-vuepress/:2:0","tags":["文档书写","vuepress"],"title":"如何使用 VuePress 写文档","uri":"https://betterrong.github.io/how-to-use-vuepress/"},{"categories":["vetgjilu"],"content":"1.1 安装 cnpm install -g vuepress//全局安装 ","date":"2020-07-21","objectID":"https://betterrong.github.io/how-to-use-vuepress/:2:1","tags":["文档书写","vuepress"],"title":"如何使用 VuePress 写文档","uri":"https://betterrong.github.io/how-to-use-vuepress/"},{"categories":["vetgjilu"],"content":"1. 2 创建项目目录 mkdir MyDocs \u0026\u0026 cd MyDocs ","date":"2020-07-21","objectID":"https://betterrong.github.io/how-to-use-vuepress/:2:2","tags":["文档书写","vuepress"],"title":"如何使用 VuePress 写文档","uri":"https://betterrong.github.io/how-to-use-vuepress/"},{"categories":["vetgjilu"],"content":"1.3 项目初始化 npm init -y 将会创建一个 package.json 文件，内容如下： { \"name\": \"MyDocs\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"index.js\", \"scripts\": { \"dev\": \"vuepress dev docs\", //用于实时预览 \"build\": \"vuepress build docs\" //用于打包项目 }, \"keywords\": [], \"author\": \"\", \"license\": \"ISC\" } ","date":"2020-07-21","objectID":"https://betterrong.github.io/how-to-use-vuepress/:2:3","tags":["文档书写","vuepress"],"title":"如何使用 VuePress 写文档","uri":"https://betterrong.github.io/how-to-use-vuepress/"},{"categories":["vetgjilu"],"content":"1.4 创建 VuePress 项目的文件夹和文件 1.4.1 文件目录结构 VuePress 遵循 “约定优于配置” 的原则，推荐的目录结构如下： . ├── docs │ ├── .vuepress (可选的) //存放核心内容的文件夹 │ │ ├── components (可选的) //存放你需要添加的vue组件 │ │ ├── theme (可选的) │ │ │ └── Layout.vue │ │ ├── public (可选的) //存放静态文件，如图片等 │ │ ├── styles (可选的) //存放需要定制的样式 │ │ │ ├── index.styl │ │ │ └── palette.styl //配置页面主题颜色的文件 │ │ ├── templates (可选的, 谨慎配置) │ │ │ ├── dev.html │ │ │ └── ssr.html │ │ ├── config.js (可选的) //设定顶部导航栏、侧边导航栏等项目配置的核心文件 │ │ └── enhanceApp.js (可选的) │ │ │ ├── README.md //首页展示用的markdown文件 │ ├── guide │ │ └── README.md │ └── config.md │ └── package.json //之前创建的Node.js项目描述文件 我的F:/MyDocs下的目录结构如下 $tree /f 卷 资料 的文件夹 PATH 列表 卷序列号为 FE22-9FCB │ package.json │ └─docs │ README.md │ ├─.vuepress │ │ config.js │ │ │ └─public │ favicon.ico │ notebooks.png │ └─Linux └─vbird1 │ README.md │ └─1-introduction 01.md 02.md 03.md ","date":"2020-07-21","objectID":"https://betterrong.github.io/how-to-use-vuepress/:2:4","tags":["文档书写","vuepress"],"title":"如何使用 VuePress 写文档","uri":"https://betterrong.github.io/how-to-use-vuepress/"},{"categories":["vetgjilu"],"content":"1.5 设置页面具体内容 1.5.1 修改 config.js 文件： module.exports = { title: '首页', // 显示在左上角的网页名称以及首页在浏览器标签显示的title名称 description: '裂泉的前端记录', // meta 中的描述文字，用于SEO // 注入到当前页面的 HTML \u003chead\u003e 中的标签 head: [ ['link', { rel: 'icon', href: '/favicon.ico' } //浏览器的标签栏的网页图标，第一个'/'会遍历public文件夹的文件 ], ], } 修改完成后，在docs/.vuepress/public 文件夹放入相应的 favicon.ico 和notebooks.png 1.5.2 设置首页内容 按照官方文档的格式修改 README.md 文件： --- home: true heroImage: /notebooks.png actionText: 鸟哥的 Linux 私房菜 actionLink: /Linux/vbird1/ features: - title: 好记性不如烂笔头 details: 一定要好好做好记录，对知识点进行整理与归纳。 - title: 分类管理笔记 details: 使用 vuepress 记录系统长期的的学习笔记，hugo 写个人博客记录零碎知识点或心得。 - title: less is more details: 简洁就是美，笔记和博客就只应该专注于记录。切记勿舍本逐末。 footer: MIT Licensed | Copyright © 2020-present Evan You --- ​``` go package myLife import( \"read\" \"coding\" \"share\" ... ) for alive == true { learn() } ​``` \u003e **好好学习，天天向上！** 温馨提示 heroImage 的地址配置第一个 ‘/’ 默认指向的是 docs/.vuepress/public，你需要在此文件夹放置你的首页图片。 actionLink 地址配置第一个 ‘/’ 默认指向的是 docs/，若未路径文件不存在点击进去会跳转至 404。文件路径之后会详细讲解。 ","date":"2020-07-21","objectID":"https://betterrong.github.io/how-to-use-vuepress/:2:5","tags":["文档书写","vuepress"],"title":"如何使用 VuePress 写文档","uri":"https://betterrong.github.io/how-to-use-vuepress/"},{"categories":["vetgjilu"],"content":"0x02 书写文档 ","date":"2020-07-21","objectID":"https://betterrong.github.io/how-to-use-vuepress/:3:0","tags":["文档书写","vuepress"],"title":"如何使用 VuePress 写文档","uri":"https://betterrong.github.io/how-to-use-vuepress/"},{"categories":["vetgjilu"],"content":"2.1 查看预览 $npm dev docs 打开 http://localhost:8080/ 可预览网站。 ","date":"2020-07-21","objectID":"https://betterrong.github.io/how-to-use-vuepress/:3:1","tags":["文档书写","vuepress"],"title":"如何使用 VuePress 写文档","uri":"https://betterrong.github.io/how-to-use-vuepress/"},{"categories":["vetgjilu"],"content":"2.2 修改页面导航栏、侧边栏导航栏 修改 config.js 文件 module.exports = { //...省略部分代码 //下面涉及到的md文件和其他文件的路径下一步再详细解释 themeConfig: { logo: '/egg.png', //网页顶端导航栏左上角的图标 //顶部导航栏 nav: [ //格式一：直接跳转，'/'为不添加路由，跳转至首页 { text: '首页', link: '/' }, //格式二：添加下拉菜单，link指向的文件路径 { text: '分类', //默认显示 ariaLabel: '分类', //用于识别的label items: [ { text: '文章', link: '/pages/folder1/test1.md' }, //点击标签会跳转至link的markdown文件生成的页面 { text: '琐碎', link: '/pages/folder2/test4.md' }, ] }, { text: '功能演示', link: '/pages/folder1/test3.md' }, //格式三：跳转至外部网页，需http/https前缀 { text: 'Github', link: 'https://github.com/dwanda' }, ], //侧边导航栏：会根据当前的文件路径是否匹配侧边栏数据，自动显示/隐藏 sidebar: { '/pages/folder1/':[ { title: '测试菜单1', // 一级菜单名称 collapsable: false, // false为默认展开菜单, 默认值true是折叠, sidebarDepth: 1, // 设置侧边导航自动提取markdown文件标题的层级，默认1为h2层级 children: [ ['test1.md', '子菜单1'], //菜单名称为'子菜单1'，跳转至/pages/folder1/test1.md ['test3.md', '子菜单2'] ] }, { title: '测试菜单2', collapsable: false, children: [ ['test2.md', '子菜单1'] ] } ], //...可添加多个不同的侧边栏，不同页面会根据路径显示不同的侧边栏 } } } 我的 config.js 文件如下 module.exports = { title: '学习笔记', description: '学习笔记文档整理', // 注入到当前页面的 HTML \u003chead\u003e 中的标签 head: [ ['link', { rel: 'icon', href: '/favicon.ico' }], // 增加一个自定义的 favicon(网页标签的图标) ], base: '/', // 这是部署到github相关的配置 下面会讲 dest: './dist', plugins: [], markdown: { lineNumbers: true // 代码块显示行号 }, themeConfig: { // search: true, searchMaxSuggestions: 10,//只会为页面的标题、h2 、 h3 以及 tags 构建搜索索引。 nav: [ { text: '主页', link: '/' }, { text: 'Linux学习', items: [ { text: '鸟哥的私房菜基础学习篇', link: '/Linux/vbird1/' } ] } ], sidebar: { '/Linux/vbird1/': [ {title: '鸟哥的私房菜基础学习篇',path: '/Linux/vbird1/'}, { title: '1 Linux的规则和安装', collapsable: false, children: [ {title: '1.1 计算机概论',path: '/Linux/vbird1/1-introduction/01'}, {title: '1.2 Linux是什么与如何学习', path: '/Linux/vbird1/1-introduction/02'}, {title: '1.3 主机规划与磁盘分区', path: '/Linux/vbird1/1-introduction/03'} ] } ] }, sidebarDepth: 2, // e'b将同时提取markdown中h2 和 h3 标题，显示在侧边栏上。 lastUpdated: 'Last Updated'// 文档更新时间：每个文件git最后提交的时间 // logo: '/logo.png',//导航栏logo // displayAllHeaders: true // 显示所有页面的标题链接： } }; 此时我们的网页首页其他页面暂时无法跳转，因为此处点击菜单跳转时，页面对应的 markdown 文件为空，会跳转至 404 页面。而侧边栏则会自动匹配当前页面路径，若侧边栏数据存在当前页面路径，则显示出来，路径匹配不到则隐藏侧边栏，这也是为什么它可以不同页面匹配不同的侧边栏的原因。 ","date":"2020-07-21","objectID":"https://betterrong.github.io/how-to-use-vuepress/:3:2","tags":["文档书写","vuepress"],"title":"如何使用 VuePress 写文档","uri":"https://betterrong.github.io/how-to-use-vuepress/"},{"categories":["vetgjilu"],"content":"2.3 markdown 及其他文件路径解析 我们的链接都是链接到 markdown 文件，在 vuepress 打包后会自动生成页面。若链接对应的 markdown 文件不存在，则会跳转 404。若存在，则跳转解析生成的页面。 还有得明确一个概念，vuepress 的文件寻址，不同类型的文件都已经预设好不同的默认路径。比如说上一步的 logo 图片引用的路径，就是遍历docs/.vuepress/public 寻找文件，我们只需要把图片放在这个文件夹就可以了。markdown 的文件就按我写的放在 docs/pages 文件夹下，里面每个文件夹名字就是一个子路径。如此类推。每个不同类型的文件必须放置在按照规定好的位置。 文件路径的默认寻址方式 和图标 / 图片等静态资源相关的，第一个 ‘/’ 默认指向的是 docs/.vuepress/public/ 侧边栏 / 导航栏链接的 markdown 文件，第一个 ‘/’ 默认指向的是 docs/，我们这里是都放置在 docs/pages 里 嵌入在 markdown 中使用的 Vue 组件，放置在 docs/.vuepress/components 目录中 ","date":"2020-07-21","objectID":"https://betterrong.github.io/how-to-use-vuepress/:3:3","tags":["文档书写","vuepress"],"title":"如何使用 VuePress 写文档","uri":"https://betterrong.github.io/how-to-use-vuepress/"},{"categories":["vetgjilu"],"content":"2.4 默认的页面路由 此处我们把 docs 目录作为 targetDir （参考 命令行接口），下面所有的 “文件的相对路径” 都是相对于 docs 目录的。 对于上述的目录结构，默认页面路由地址如下： 文件的相对路径 页面路由地址 /README.md / /guide/README.md /guide/ /config.md /config.html ","date":"2020-07-21","objectID":"https://betterrong.github.io/how-to-use-vuepress/:3:4","tags":["文档书写","vuepress"],"title":"如何使用 VuePress 写文档","uri":"https://betterrong.github.io/how-to-use-vuepress/"},{"categories":["vetgjilu"],"content":"0x03 其他问题 ","date":"2020-07-21","objectID":"https://betterrong.github.io/how-to-use-vuepress/:4:0","tags":["文档书写","vuepress"],"title":"如何使用 VuePress 写文档","uri":"https://betterrong.github.io/how-to-use-vuepress/"},{"categories":["vetgjilu"],"content":"3.1 热更新问题 由于项目结构没有热更新，所以每次调整 config.js 之后，都需要重新 npm run dev 一次。更新已存在的 markdown 文件的时候会实时热更新。 ","date":"2020-07-21","objectID":"https://betterrong.github.io/how-to-use-vuepress/:4:1","tags":["文档书写","vuepress"],"title":"如何使用 VuePress 写文档","uri":"https://betterrong.github.io/how-to-use-vuepress/"},{"categories":["vetgjilu"],"content":"3.2 修改主题颜色 只需要在我们的 '.vuepress/styles/palette.styl’ 文件中添加一下代码，再修改它的颜色进行保存，就会自动改变。 // 默认值 $accentColor = #3eaf7c //主题颜色 $textColor = #2c3e50 $borderColor = #eaecef $codeBgColor = #282c34 $badgeTipColor = #42b983 $badgeWarningColor = darken(#ffe564, 35%) $badgeErrorColor = #DA5961 ","date":"2020-07-21","objectID":"https://betterrong.github.io/how-to-use-vuepress/:4:2","tags":["文档书写","vuepress"],"title":"如何使用 VuePress 写文档","uri":"https://betterrong.github.io/how-to-use-vuepress/"},{"categories":["vetgjilu"],"content":"3.3 在 markdown 中嵌入 vue 组件 首先先把 vue 组件编辑好，直接放在我们之前创建的 docs/.vuepress/components 文件夹中。只需要在 markdown 文件中，直接按下面的方法使用组件。无需其他引入即可加载 vue 组件。 \u003cClientOnly\u003e \u003cHomeLayout/\u003e //你的组件名字 \u003c/ClientOnly\u003e ","date":"2020-07-21","objectID":"https://betterrong.github.io/how-to-use-vuepress/:4:3","tags":["文档书写","vuepress"],"title":"如何使用 VuePress 写文档","uri":"https://betterrong.github.io/how-to-use-vuepress/"},{"categories":["vetgjilu"],"content":"3.4 markdown 内容的其他扩展 添加本地图片资源 markdown 的样式其他扩展规则，包括代码行号、不同格式代码的高亮、自定义容器等。 markdown 的链接的默认跳转规则，默认都是跳转至网站内部的其他页面，如需跳转至外部页面记得加上 http/https 前缀。 ","date":"2020-07-21","objectID":"https://betterrong.github.io/how-to-use-vuepress/:4:4","tags":["文档书写","vuepress"],"title":"如何使用 VuePress 写文档","uri":"https://betterrong.github.io/how-to-use-vuepress/"},{"categories":["vetgjilu"],"content":"3.5 自定义容器 ::: tip 这里是替换内容 这里是内容 ::: ","date":"2020-07-21","objectID":"https://betterrong.github.io/how-to-use-vuepress/:4:5","tags":["文档书写","vuepress"],"title":"如何使用 VuePress 写文档","uri":"https://betterrong.github.io/how-to-use-vuepress/"},{"categories":["vetgjilu"],"content":"3.6 官网一些其他功能 整体目录结构 config.js 的其他细节配置 开启页面自动记录上一次修改时间，并显示在页面右下角 开启 pwa，实现离线缓存 开发自己的主题 ","date":"2020-07-21","objectID":"https://betterrong.github.io/how-to-use-vuepress/:4:6","tags":["文档书写","vuepress"],"title":"如何使用 VuePress 写文档","uri":"https://betterrong.github.io/how-to-use-vuepress/"},{"categories":["vetgjilu"],"content":"0x04 参考 1 小时搞定 vuepress 快速制作 vue 文档 / 博客 + 免费部署预览 VuePress 中文文档 | VuePress 中文网 VuePress 手把手一小時快速踩坑 VuePress 手摸手教你搭建一个类 Vue 文档风格的技术文档 / 博客 ","date":"2020-07-21","objectID":"https://betterrong.github.io/how-to-use-vuepress/:5:0","tags":["文档书写","vuepress"],"title":"如何使用 VuePress 写文档","uri":"https://betterrong.github.io/how-to-use-vuepress/"},{"categories":["documentation"],"content":"本文记录 sprintf 的一些常见用法。","date":"2020-07-20","objectID":"https://betterrong.github.io/how-to-use-sprintf/","tags":["c","标准库","转载"],"title":"sprintf()的用法（转载）","uri":"https://betterrong.github.io/how-to-use-sprintf/"},{"categories":["documentation"],"content":" sprintf函数的功能与printf函数的功能基本一样，只是它把结果输出到指定的字符串中。 ","date":"2020-07-20","objectID":"https://betterrong.github.io/how-to-use-sprintf/:0:0","tags":["c","标准库","转载"],"title":"sprintf()的用法（转载）","uri":"https://betterrong.github.io/how-to-use-sprintf/"},{"categories":["documentation"],"content":"0x00 简介 头文件 #include \u003cstdio.h\u003e 函数功能：格式化字符串，将格式化的数据写入字符串中。 函数原型： nt sprintf(char *buffer, const char *format, [argument]…) 参数： buffer：是char类型的指针，指向写入的字符串指针。 format：格式化字符串，即在程序中想要的格式， argument：可选参数，可以为任意类型的数据， 函数返回值：buffer指向的字符串的长度。 ","date":"2020-07-20","objectID":"https://betterrong.github.io/how-to-use-sprintf/:1:0","tags":["c","标准库","转载"],"title":"sprintf()的用法（转载）","uri":"https://betterrong.github.io/how-to-use-sprintf/"},{"categories":["documentation"],"content":"用法 ","date":"2020-07-20","objectID":"https://betterrong.github.io/how-to-use-sprintf/:2:0","tags":["c","标准库","转载"],"title":"sprintf()的用法（转载）","uri":"https://betterrong.github.io/how-to-use-sprintf/"},{"categories":["documentation"],"content":"格式化数字字符串 sprintf和printf的用法一样，只是打印到的位置不同而已，前者打印给buffer字符串，后者打印给标准输出，所以sprintf也可以用来将整型转化为字符串，比itoa效率高且十分简便，例如： sprintf(buffer, “%d”, 123456); //执行后buffer即指向字符串“123456” ","date":"2020-07-20","objectID":"https://betterrong.github.io/how-to-use-sprintf/:2:1","tags":["c","标准库","转载"],"title":"sprintf()的用法（转载）","uri":"https://betterrong.github.io/how-to-use-sprintf/"},{"categories":["documentation"],"content":"连接字符 连接以’\\0’结束的字符串： #include \u003cstdio.h\u003eint main(int argc, char *argv[]){ char buffer[10]; char *a = \"1234\"; char *b = \"5678\"; sprintf(buffer,\"%s%s\", a, b); printf(\"%s\\n\", buffer); return 0; } 运行结果： 连接结尾没有’\\0’的字符数组或字符串缓冲区： #include\u003cstdio.h\u003e int main() { char a[] = {'0','1', '2', '3', '4'}; char b[] = {'5', '6', '7', '8'}; char buffer[10]; sprintf(buffer, \"%.5s%.4s\", a, b); printf(\"%s\\n\", buffer); return 0; } 如果我们想动态获取要处理的字符缓冲区长度，则将上面sprintf改为： sprintf(buffer, \"%.*s%.*s\", sizeof(a), a, sizeof(b), b); ","date":"2020-07-20","objectID":"https://betterrong.github.io/how-to-use-sprintf/:2:2","tags":["c","标准库","转载"],"title":"sprintf()的用法（转载）","uri":"https://betterrong.github.io/how-to-use-sprintf/"},{"categories":["documentation"],"content":"利用sprintf中的返回值 在”AOV网络和拓扑（二）——实现“篇中，有这样一行程序: pos += sprintf(output+pos, “%d “, j+1); 它的作用是什么呢？ 因为sprintf函数的返回值为output+pos所指向字符串的长度，所以对于pos来说，相当于执行了一次pos+=sizeof(output+pos)，如果这条语句放在一个循环里，则第二次执行sprintf时output+pos随即指向了当前缓冲区的末尾（注意不是output的末尾！否则会读取非法内存！），这样就可以生成一个具有一定规则的字符串了~写个例子： #include \u003cstdio.h\u003eint main() { char buf[100]; int pos = 0; for (int j = 0; j \u003c 10; j++) pos += sprintf(buf + pos, \"%d-\", j); buf[pos - 1] = '\\n'; //将最后一个字符'-'转换为'\\n' printf(buf); return 0; } 运行结果： pos每次增加2，因为每次buf字符串后面都要加上两个字符j和‘-’。 原文链接 ","date":"2020-07-20","objectID":"https://betterrong.github.io/how-to-use-sprintf/:2:3","tags":["c","标准库","转载"],"title":"sprintf()的用法（转载）","uri":"https://betterrong.github.io/how-to-use-sprintf/"},{"categories":["uxti"],"content":"给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。 示例 1: 输入: 123 输出: 321 示例 2: 输入: -123 输出: -321 示例 3: 输入: 120 输出: 21 注意: 假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231, 231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。 Solution: #define isOverLength 0 int reverse(int x){ long lRet = 0; while(0 != x) { lRet = lRet * 10 + x % 10; x = x / 10; } if((int)lRet != lRet) { return isOverLength; } return (int)lRet; } func reverse(x int) int { var ans int for x != 0 { ans = ans * 10 + x % 10 x = x / 10 } if ans \u003c math.MinInt32 || ans \u003e math.MaxInt32 { return 0 } return ans } 7. 整数反转 ","date":"2020-07-19","objectID":"https://betterrong.github.io/leetcode-7/:0:0","tags":["leetcode","c","go"],"title":"leetcode 7. 整数反转","uri":"https://betterrong.github.io/leetcode-7/"},{"categories":["uxti"],"content":"判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。 示例 1: 输入: 121 输出: true 示例 2: 输入: -121 输出: false 解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。 示例 3: 输入: 10 输出: false 解释: 从右向左读, 为 01 。因此它不是一个回文数。 进阶: 你能不将整数转为字符串来解决这个问题吗？ Solution: /* * @lc app=leetcode.cn id=9 lang=c * * [9] 回文数 */ // @lc code=start bool isPalindrome(int x) { // change x into string // char x_c[20]; // char str[20]; // char temp; //一开始的想法，反转字符串后再与原字符串比较 // sprintf(str, \"%d\", x); // strcpy(x_c, str); // //反转字符串 // for (int i = 0, j = strlen(x_c)-1; i \u003c j; i++, j--) { // temp = x_c[i]; // x_c[i] = x_c[j]; // x_c[j] = temp; // } // if (!strcmp(str, x_c)) { // return true; // } // return false; char x_c[20]; sprintf(x_c, \"%d\", x); int len = strlen(x_c); for (int i = 0; i \u003c len / 2; i++) { if (x_c[i] != x_c[len - 1 - i]) { return false; } } return true; } // @lc code=end /* * @lc app=leetcode.cn id=9 lang=golang * * [9] 回文数 */ // @lc code=start func isPalindrome(x int) bool { var x_c string = strconv.Itoa(x) var le int = len(x_c) for i := 0;i \u003c le/2; i++ { if x_c[i] != x_c[le-1-i] { return false } } return true } // @lc code=end 9. 回文数 ","date":"2020-07-19","objectID":"https://betterrong.github.io/leetcode-9/:0:0","tags":["leetcode","c","go"],"title":"leetcode 9. 回文数","uri":"https://betterrong.github.io/leetcode-9/"},{"categories":["uxti"],"content":"给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。 示例: 给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9 所以返回 [0, 1] Solution： /** * Note: The returned array must be malloced, assume caller calls free(). */ //暴力法 int* twoSum(int* nums, int numsSize, int target, int* returnSize){ int *ret = (int *)malloc(2*sizeof(int)); for(int i = 0; i \u003c numsSize; i++) { for(int j = i + 1; j \u003c numsSize; j++) { if(nums[j] + nums[i] == target) { ret[0] = i; ret[1] = j; *returnSize = 2; return ret; } } } return 0; } //更好的解决方法：使用哈希表 //暴力法 func twoSum(nums []int, target int) []int { for i := 0; i \u003c len(nums); i++ { for j := i + 1; j \u003c len(nums); j ++ { if nums[i] + nums[j] == target { return [] int {i,j} } } } return [] int {} } //map法 func twoSum(nums []int, target int) []int { length := len(nums) for i, v := range nums{ for j:=i+1; j\u003clength; j++ { if nums[j] == target - v{ return []int{i, j} } } } return []int{} } 1. 两数之和 ","date":"2020-07-18","objectID":"https://betterrong.github.io/leetcode-1/:0:0","tags":["leetcode","c","go"],"title":"leetcode 1. 两数之和","uri":"https://betterrong.github.io/leetcode-1/"},{"categories":["uxti"],"content":"给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。 你可以假设数组中无重复元素。 示例 1: 输入: [1,3,5,6], 5 输出: 2 示例 2: 输入: [1,3,5,6], 2 输出: 1 示例 3: 输入: [1,3,5,6], 7 输出: 4 示例 4: 输入: [1,3,5,6], 0 输出: 0 Solution： int searchInsert(int* nums, int numsSize, int target){ int location; for(int i = 0 ; i \u003c numsSize; ++ i) { if(target == nums[i]) { location = i; break; } else if(target \u003c nums[i]) { if(i == 0) { location = 0; } else { location = i; } break; }else if(i == numsSize-1) { location = i + 1; break; } } return location; } //二分法 // int searchInsert(int* nums, int numsSize, int target) { // int left = 0, right = numsSize - 1, ans = numsSize; // while (left \u003c= right) { // int mid = ((right - left) \u003e\u003e 1) + left; // if (target \u003c= nums[mid]) { // ans = mid; // right = mid - 1; // } else { // left = mid + 1; // } // } // return ans; // } func searchInsert(nums []int, target int) int { if target \u003e nums[len(nums)-1] { return len(nums) } for i := 0; i \u003c len(nums); i++ { if target == nums[i] || target \u003c nums[i] { return i } } return 0 } //二分法 // func searchInsert(nums []int, target int) int { // n := len(nums) // left, right := 0, n - 1 // ans := n // for left \u003c= right { // mid := (right - left) \u003e\u003e 1 + left // if target \u003c= nums[mid] { // ans = mid // right = mid - 1 // } else { // left = mid + 1 // } // } // return ans // } 35. 搜索插入位置 ","date":"2020-07-17","objectID":"https://betterrong.github.io/leecode-35/:0:0","tags":["leetcode","c","go"],"title":"leetcode 35. 搜索插入位置","uri":"https://betterrong.github.io/leecode-35/"},{"categories":["vetgjilu"],"content":"hugo博客添加自定义页面并搭建个人图床。","date":"2020-07-01","objectID":"https://betterrong.github.io/add-nav/","tags":["blog"],"title":"hugo博客添加键盘导航","uri":"https://betterrong.github.io/add-nav/"},{"categories":["vetgjilu"],"content":"1 前言 最近发现之前加的一个纪录片交流群改成了一个导航网站交流群，进去和他们聊了会，勾起了我对导航网站的好奇。平时不用导航网站，也就是收藏了几个专业的垂直导航，比如前端导航、优设导航这样的，有需要的时候再用。在好奇心的驱动下，我去网上浏览了一堆导航网站，浏览过程中我发现了一个很有想法的导航网站，我很喜欢。在一番研究下，我把它集成到了我的个人博客，然后改为我的浏览器主页。 这篇文章会详细记录置过程，在配置过程中顺便搭建了个人图床使用gitee搭建，搭建过程也一并记录下来。 ","date":"2020-07-01","objectID":"https://betterrong.github.io/add-nav/:1:0","tags":["blog"],"title":"hugo博客添加键盘导航","uri":"https://betterrong.github.io/add-nav/"},{"categories":["vetgjilu"],"content":"2 hugo站点目录结构 用hugo生成的站点目录结构如下： │ config.toml │ ├─archetypes ├─content ├─data ├─layouts ├─static ├─public └─themes config.toml，站点全局的参数配置文件，在里面可以定义博客地址、构建配置、标题、导航栏等等。 archetypes，Hugo的markdown文件中前置数据Front Matter定义的结构，储存.md的模板文件,在创建新内容时自动生成内容的配置。默认使用的是default.md文件，可以自定义，该文件夹的优先级高于主题下的/archetypes文件夹。Front Matter支持三种格式，除了yaml，还支持toml，json方式。 content，存放网页内容的目录，即我们编写的markdown文件都存放在此目录，此目录是Hugo的默认源目录。 data， data目录用来存放数据文件，一般是json文件，Hugo提供了相关命令可以从data目录下读取相关的文件数据，然后渲染到HTML页面中，将业务数据与模板分离。 layouts，存放自定义的模板文件，该文件夹的优先级高于主题下的/layouts文件夹。 static，存放静态文件，比如css、js、img等文件目录，Hugo在渲染时，会直接将static目录下的文件直接复制到public目录下，不会做任何渲染。 public，执行hugo命令后，储存生成的静态文件。 themes，存放网站主题，可以下载多个主题，themes目录下的每个子目录代表了一个主题。 所以，我们要想为博客添加自定义页面就必须把我们自定义的页面放到/static文件夹下，static这个文件夹有一个特性就是可以将里面的文件复制到public文件夹里面。因为它不是hugo生成的，所以不会被覆盖。 ","date":"2020-07-01","objectID":"https://betterrong.github.io/add-nav/:2:0","tags":["blog"],"title":"hugo博客添加键盘导航","uri":"https://betterrong.github.io/add-nav/"},{"categories":["vetgjilu"],"content":"3 修改配置文件 编辑config.toml，在[languages.zh-cn.menu]下方插入如下内容： [[languages.zh-cn.menu.main]] identifier = \"navigation\" pre = \"⌨\" post = \"\" name = \"键盘导航\" url = \"/navigation/\" title = \"友情链接\" weight = 5 然后，重新生成public文件夹， 输入命令后进入localhost:1313查看效果： hugo serve -e production 点击“键盘导航”即可跳转到自定义导航页面了。 \" ","date":"2020-07-01","objectID":"https://betterrong.github.io/add-nav/:3:0","tags":["blog"],"title":"hugo博客添加键盘导航","uri":"https://betterrong.github.io/add-nav/"},{"categories":["vetgjilu"],"content":"4 图床搭建 搭建图床，用来方便地管理个人图片，接下来用gitee实现图床搭建。 ","date":"2020-07-01","objectID":"https://betterrong.github.io/add-nav/:4:0","tags":["blog"],"title":"hugo博客添加键盘导航","uri":"https://betterrong.github.io/add-nav/"},{"categories":["vetgjilu"],"content":"4.1 创建仓库 登入gitee，新建一个仓库。 \" \" ","date":"2020-07-01","objectID":"https://betterrong.github.io/add-nav/:4:1","tags":["blog"],"title":"hugo博客添加键盘导航","uri":"https://betterrong.github.io/add-nav/"},{"categories":["vetgjilu"],"content":"4.2 创建文件夹 在本地创建一个图床文件夹。 \" 初始化然后手动关联本地文件夹与远程仓库： $ cd imagebed $ git remote add origin https://gitee.com/likebetter/imagebed.git \" \" ","date":"2020-07-01","objectID":"https://betterrong.github.io/add-nav/:4:2","tags":["blog"],"title":"hugo博客添加键盘导航","uri":"https://betterrong.github.io/add-nav/"},{"categories":["vetgjilu"],"content":"4.3 开启Gitee Pages 在仓库中打开服务选项，选择Gitee Pages： \" 启动Gitee Pages服务 \" 部署完成，可看到生成的图床地址： \" ","date":"2020-07-01","objectID":"https://betterrong.github.io/add-nav/:4:3","tags":["blog"],"title":"hugo博客添加键盘导航","uri":"https://betterrong.github.io/add-nav/"},{"categories":["vetgjilu"],"content":"4.4 上传图片 创建imgs文件夹，放入图片，提交即可。 这里我对图床做了美化，放入了一个自定义页面于/imagebed文件夹下 \" \" 通过在该地址后面拼接远程仓库内的图片目录，就能将图片显示出来。比如位于远程仓库如下目录中的link_ico.png图片： \" ","date":"2020-07-01","objectID":"https://betterrong.github.io/add-nav/:4:4","tags":["blog"],"title":"hugo博客添加键盘导航","uri":"https://betterrong.github.io/add-nav/"},{"categories":["vetgjilu"],"content":"5 参考 【教程】使用gitee搭建免费的图床 使用Gitee搭建个人图床 hugo介绍及使用 Hugo 从入门到会用 ","date":"2020-07-01","objectID":"https://betterrong.github.io/add-nav/:5:0","tags":["blog"],"title":"hugo博客添加键盘导航","uri":"https://betterrong.github.io/add-nav/"},{"categories":["vetgjilu"],"content":"因为不想在编码时双手频繁离开主键盘区去按方向键，所以更改了一些设置。","date":"2020-06-26","objectID":"https://betterrong.github.io/vsc-keyboard-shortcuts/","tags":["tool","vscode"],"title":"修改vscode中的键盘快捷方式","uri":"https://betterrong.github.io/vsc-keyboard-shortcuts/"},{"categories":["vetgjilu"],"content":"调整选择补全 打开keybindings.json，添加以下内容： { \"key\": \"tab\", \"command\": \"acceptSelectedSuggestion\", \"when\": \"suggestWidgetVisible \u0026\u0026 textInputFocus\" }, { \"key\": \"shift+tab\", \"command\": \"acceptSelectedSuggestion\", \"when\": \"suggestWidgetVisible \u0026\u0026 textInputFocus\" }, { \"key\": \"tab\", \"command\": \"selectNextSuggestion\", \"when\": \"editorTextFocus \u0026\u0026 suggestWidgetMultipleSuggestions \u0026\u0026 suggestWidgetVisible\" }, { \"key\": \"shift+tab\", \"command\": \"selectPrevSuggestion\", \"when\": \"editorTextFocus \u0026\u0026 suggestWidgetMultipleSuggestions \u0026\u0026 suggestWidgetVisible\" } 如此即可实现按tab键、shift+tab循环选择suggestion，Enter键accept。 ","date":"2020-06-26","objectID":"https://betterrong.github.io/vsc-keyboard-shortcuts/:1:0","tags":["tool","vscode"],"title":"修改vscode中的键盘快捷方式","uri":"https://betterrong.github.io/vsc-keyboard-shortcuts/"},{"categories":["vetgjilu"],"content":"组合键代替方向键移动光标 打开keybindings.json，添加以下内容： { \"key\": \"shift+j\", \"command\": \"cursorLeft\", \"when\": \"textInputFocus\" }, { \"key\": \"left\", \"command\": \"-cursorLeft\", \"when\": \"textInputFocus\" }, { \"key\": \"shift+l\", \"command\": \"cursorRight\", \"when\": \"textInputFocus\" }, { \"key\": \"right\", \"command\": \"-cursorRight\", \"when\": \"textInputFocus\" }, { \"key\": \"shift+i\", \"command\": \"cursorUp\", \"when\": \"textInputFocus\" }, { \"key\": \"up\", \"command\": \"-cursorUp\", \"when\": \"textInputFocus\" }, { \"key\": \"shift+k\", \"command\": \"cursorDown\", \"when\": \"textInputFocus\" }, { \"key\": \"down\", \"command\": \"-cursorDown\", \"when\": \"textInputFocus\" } 即可实现shift+j左移光标，shift+l右移光标，shift+i上移光标，shift+k下移光标。 ","date":"2020-06-26","objectID":"https://betterrong.github.io/vsc-keyboard-shortcuts/:2:0","tags":["tool","vscode"],"title":"修改vscode中的键盘快捷方式","uri":"https://betterrong.github.io/vsc-keyboard-shortcuts/"},{"categories":["documentation"],"content":"测试markdown的语法，测试shortcode的使用。","date":"2020-06-16","objectID":"https://betterrong.github.io/how-to-write-md/","tags":["markdown","hugo"],"title":"如何编写markdown（备份）","uri":"https://betterrong.github.io/how-to-write-md/"},{"categories":["documentation"],"content":" WYSIWYG所见即所得 Markdown基本语法参考 ","date":"2020-06-16","objectID":"https://betterrong.github.io/how-to-write-md/:0:0","tags":["markdown","hugo"],"title":"如何编写markdown（备份）","uri":"https://betterrong.github.io/how-to-write-md/"},{"categories":["documentation"],"content":"1 打字机动画 ","date":"2020-06-16","objectID":"https://betterrong.github.io/how-to-write-md/:1:0","tags":["markdown","hugo"],"title":"如何编写markdown（备份）","uri":"https://betterrong.github.io/how-to-write-md/"},{"categories":["documentation"],"content":"1.1 简单内容 {{\u003c typeit \u003e}} 这一个带有基于 [TypeIt](https://typeitjs.com/) 的 **打字动画** 的 *段落*... {{\u003c /typeit \u003e}} 一个带有 h4 标签的 typeit 示例: {{\u003c typeit tag=h4 \u003e}} 这一个带有基于 [TypeIt](https://typeitjs.com/) 的 **打字动画** 的 *段落*... {{\u003c /typeit \u003e}} 呈现的输出效果如下: ","date":"2020-06-16","objectID":"https://betterrong.github.io/how-to-write-md/:1:1","tags":["markdown","hugo"],"title":"如何编写markdown（备份）","uri":"https://betterrong.github.io/how-to-write-md/"},{"categories":["documentation"],"content":"1.2 代码内容 代码内容也是允许的, 并且通过使用参数 code 指定语言类型可以实习语法高亮. 一个带有 code 参数的 typeit 示例: {{\u003c typeit code=go \u003e}} package main import \"fmt\" func main() { fmt.Println(\"hello,world!\") } {{\u003c /typeit \u003e}} 呈现的输出效果如下: ","date":"2020-06-16","objectID":"https://betterrong.github.io/how-to-write-md/:1:3","tags":["markdown","hugo"],"title":"如何编写markdown（备份）","uri":"https://betterrong.github.io/how-to-write-md/"},{"categories":["documentation"],"content":"1.3 分组内容 按顺序开始一组 typeit 内容的打字动画。 一组具有相同 group 参数值的 typeit 内容将按顺序开始打字动画。 示例： {{\u003c typeit group=paragraph \u003e}} **首先**, 这个段落开始 {{\u003c /typeit \u003e}} {{\u003c typeit group=paragraph \u003e}} **然后**, 这个段落开始 {{\u003c /typeit \u003e}} 呈现的输出效果如下: ","date":"2020-06-16","objectID":"https://betterrong.github.io/how-to-write-md/:1:4","tags":["markdown","hugo"],"title":"如何编写markdown（备份）","uri":"https://betterrong.github.io/how-to-write-md/"},{"categories":["documentation"],"content":"2 横幅 {{\u003c admonition type=tip title=\"This is a tip\" open=false \u003e}} 一个 **技巧** 横幅 {{\u003c /admonition \u003e}} 或者 {{\u003c admonition tip \"This is a tip\" false \u003e}} 一个 **技巧** 横幅 {{\u003c /admonition \u003e}} This is a tip 一个 技巧 横幅 admonition shortcode 支持 12 种 帮助你在页面中插入提示的横幅. 注意 一个 注意 横幅 note 摘要 一个 摘要 横幅 abstract 信息 一个 信息 横幅 info 技巧 一个 技巧 横幅 tip 成功 一个 成功 横幅 success 问题 一个 问题 横幅 question 警告 一个 警告 横幅 warning 失败 一个 失败 横幅 failure 危险 一个 危险 横幅 danger Bug 一个 Bug 横幅 bug 示例 一个 示例 横幅 example 引用 一个 引用 横幅 quote ","date":"2020-06-16","objectID":"https://betterrong.github.io/how-to-write-md/:2:0","tags":["markdown","hugo"],"title":"如何编写markdown（备份）","uri":"https://betterrong.github.io/how-to-write-md/"},{"categories":["documentation"],"content":"3 mermaid mermaid 是一个可以帮助你在文章中生成图表和流程图的库, 类似 Markdown 的语法。 只需将你的 mermaid 代码插入 mermaid shortcode 中即可。 ","date":"2020-06-16","objectID":"https://betterrong.github.io/how-to-write-md/:3:0","tags":["markdown","hugo"],"title":"如何编写markdown（备份）","uri":"https://betterrong.github.io/how-to-write-md/"},{"categories":["documentation"],"content":"3.1 流程图 {{\u003c mermaid \u003e}} graph LR; A[Hard edge] --\u003e|Link text| B(Round edge) B --\u003e C{Decision} C --\u003e|One| D[Result one] C --\u003e|Two| E[Result two] {{\u003c /mermaid \u003e}} ","date":"2020-06-16","objectID":"https://betterrong.github.io/how-to-write-md/:3:1","tags":["markdown","hugo"],"title":"如何编写markdown（备份）","uri":"https://betterrong.github.io/how-to-write-md/"},{"categories":["documentation"],"content":"3.2 饼图 一个 饼图 mermaid 示例: {{\u003c mermaid \u003e}} pie \"东部\" : 112 \"西部\" : 56 \"北部\" : 24 \"南部\" : 8 {{\u003c /mermaid \u003e}} 呈现的输出效果如下: ","date":"2020-06-16","objectID":"https://betterrong.github.io/how-to-write-md/:3:2","tags":["markdown","hugo"],"title":"如何编写markdown（备份）","uri":"https://betterrong.github.io/how-to-write-md/"},{"categories":["documentation"],"content":"4 echarts ECharts 是一个帮助你生成交互式数据可视化的库。 ECharts 提供了常规的 折线图, 柱状图, 散点图, 饼图, K线图, 用于统计的 盒形图, 用于地理数据可视化的 地图, 热力图, 线图, 用于关系数据可视化的 关系图, treemap, 旭日图, 多维数据可视化的 平行坐标, 还有用于 BI 的 漏斗图, 仪表盘, 并且支持图与图之间的混搭。 只需在 echarts shortcode 中以 JSON/YAML/TOML格式插入 ECharts 选项即可。 一个 TOML 格式的 echarts 示例: {{\u003c echarts \u003e}} [title] text = \"折线统计图\" top = \"2%\" left = \"center\" [tooltip] trigger = \"axis\" [legend] data = [ \"邮件营销\", \"联盟广告\", \"视频广告\", \"直接访问\", \"搜索引擎\" ] top = \"10%\" [grid] left = \"5%\" right = \"5%\" bottom = \"5%\" top = \"20%\" containLabel = true [toolbox] [toolbox.feature] [toolbox.feature.saveAsImage] title = \"保存为图片\" [xAxis] type = \"category\" boundaryGap = false data = [ \"周一\", \"周二\", \"周三\", \"周四\", \"周五\", \"周六\", \"周日\" ] [yAxis] type = \"value\" [[series]] name = \"邮件营销\" type = \"line\" stack = \"总量\" data = [ 120.0, 132.0, 101.0, 134.0, 90.0, 230.0, 210.0 ] [[series]] name = \"联盟广告\" type = \"line\" stack = \"总量\" data = [ 220.0, 182.0, 191.0, 234.0, 290.0, 330.0, 310.0 ] [[series]] name = \"视频广告\" type = \"line\" stack = \"总量\" data = [ 150.0, 232.0, 201.0, 154.0, 190.0, 330.0, 410.0 ] [[series]] name = \"直接访问\" type = \"line\" stack = \"总量\" data = [ 320.0, 332.0, 301.0, 334.0, 390.0, 330.0, 320.0 ] [[series]] name = \"搜索引擎\" type = \"line\" stack = \"总量\" data = [ 820.0, 932.0, 901.0, 934.0, 1290.0, 1330.0, 1320.0 ] {{\u003c /echarts \u003e}} 呈现的输出效果如下: ","date":"2020-06-16","objectID":"https://betterrong.github.io/how-to-write-md/:4:0","tags":["markdown","hugo"],"title":"如何编写markdown（备份）","uri":"https://betterrong.github.io/how-to-write-md/"},{"categories":["documentation"],"content":"5 mappbox Mapbox GL JS 是一个 JavaScript 库，它使用 WebGL, 以 vector tiles 和 Mapbox styles 为来源, 将它们渲染成互动式地图. mapbox shortcode 有以下命名参数来使用 Mapbox GL JS: lng [必需] (第一个位置参数) 地图初始中心点的经度, 以度为单位. lat [必需] (第二个位置参数) 地图初始中心点的纬度, 以度为单位. zoom [可选] (第三个位置参数) 地图的初始缩放级别, 默认值是 10. marked [可选] (第四个位置参数) 是否在地图的初始中心点添加图钉, 默认值是 true. light-style [可选] (第五个位置参数) 浅色主题的地图样式, 默认值是前置参数或者网站配置中设置的值. dark-style [可选] (第六个位置参数) 深色主题的地图样式, 默认值是前置参数或者网站配置中设置的值. navigation [可选] 是否添加 NavigationControl, 默认值是前置参数或者网站配置中设置的值. geolocate [可选] 是否添加 GeolocateControl, 默认值是前置参数或者网站配置中设置的值. scale [可选] 是否添加 ScaleControl, 默认值是前置参数或者网站配置中设置的值. fullscreen [可选] 是否添加 FullscreenControl, 默认值是前置参数或者网站配置中设置的值. width [可选] 地图的宽度, 默认值是 100%. height [可选] 地图的高度, 默认值是 20rem. 一个简单的 mapbox 示例: {{\u003c mapbox 112.500 27.918 10 true \"mapbox://styles/mapbox/streets-zh-v1?optimize=true\" \u003e}} 呈现的输出效果如下: ","date":"2020-06-16","objectID":"https://betterrong.github.io/how-to-write-md/:5:0","tags":["markdown","hugo"],"title":"如何编写markdown（备份）","uri":"https://betterrong.github.io/how-to-write-md/"},{"categories":["documentation"],"content":"6 音乐 ","date":"2020-06-16","objectID":"https://betterrong.github.io/how-to-write-md/:6:0","tags":["markdown","hugo"],"title":"如何编写markdown（备份）","uri":"https://betterrong.github.io/how-to-write-md/"},{"categories":["documentation"],"content":"6.1 自定义音乐url 支持本地资源引用的完整用法。 一个使用自定义音乐 URL 的 music 示例: {{\u003c music url=\"/music/Intro.mp3\" name=intro artist=王备 cover=\"/images/intro.jpg\" \u003e}} ","date":"2020-06-16","objectID":"https://betterrong.github.io/how-to-write-md/:6:1","tags":["markdown","hugo"],"title":"如何编写markdown（备份）","uri":"https://betterrong.github.io/how-to-write-md/"},{"categories":["documentation"],"content":"6.2 音乐平台 URL 的自动识别 一个使用音乐平台 URL 的自动识别的 music 示例: {{\u003c music auto=\"https://music.163.com/#/album?id=39308\" \u003e}} 或者 {{\u003c music \"https://music.163.com/#/album?id=39308\" \u003e}} 呈现的输出效果如下: ","date":"2020-06-16","objectID":"https://betterrong.github.io/how-to-write-md/:6:2","tags":["markdown","hugo"],"title":"如何编写markdown（备份）","uri":"https://betterrong.github.io/how-to-write-md/"},{"categories":["documentation"],"content":"6.3 自定义音乐平台, 类型和 ID music shortcode 有以下命名参数来使用自定义音乐平台: server [必需] (第一个位置参数) [netease, tencent, kugou, xiami, baidu] 音乐平台. type [必需] (第二个位置参数) [song, playlist, album, search, artist] 音乐类型. id [必需] (第三个位置参数) 歌曲 ID, 或者播放列表 ID, 或者专辑 ID, 或者搜索关键词, 或者创作者 ID. 一个使用自定义音乐平台的 music 示例: {{\u003c music server=\"netease\" type=\"song\" id=\"122672\" \u003e}} 或者 {{\u003c music netease song 122672 \u003e}} 呈现的输出效果如下: ","date":"2020-06-16","objectID":"https://betterrong.github.io/how-to-write-md/:6:3","tags":["markdown","hugo"],"title":"如何编写markdown（备份）","uri":"https://betterrong.github.io/how-to-write-md/"},{"categories":["documentation"],"content":"6.4 其他参数 music shortcode 有一些可以应用于以上三种方式的其它命名参数: theme [可选] 音乐播放器的主题色, 默认值是 #448aff. fixed [可选] 是否开启固定模式, 默认值是 false. mini [可选] 是否开启迷你模式, 默认值是 false. autoplay [可选] 是否自动播放音乐, 默认值是 false. volume [可选] 第一次打开播放器时的默认音量, 会被保存在浏览器缓存中, 默认值是 0.7. mutex [可选] 是否自动暂停其它播放器, 默认值是 true. music shortcode 还有一些只适用于音乐列表方式的其它命名参数: loop [可选] [all, one, none] 音乐列表的循环模式, 默认值是 none. order [可选] [list, random] 音乐列表的播放顺序, 默认值是 list. list-folded [可选] 初次打开的时候音乐列表是否折叠, 默认值是 false. list-max-height [可选] 音乐列表的最大高度, 默认值是 340px. ","date":"2020-06-16","objectID":"https://betterrong.github.io/how-to-write-md/:6:4","tags":["markdown","hugo"],"title":"如何编写markdown（备份）","uri":"https://betterrong.github.io/how-to-write-md/"},{"categories":["documentation"],"content":"7 哔哩哔哩 bilibili shortcode 提供了一个内嵌的用来播放 bilibili 视频的响应式播放器. 如果视频只有一个部分, 则仅需要视频的 BV id, 例如: https://www.bilibili.com/video/BV1hW41197Fi 一个 bilibili 示例: {{\u003c bilibili BV1hW41197Fi \u003e}} 或者 {{\u003c bilibili id=BV1hW41197Fi \u003e}} 呈现的输出效果如下: 如果视频包含多个部分, 则除了视频的 BV id 之外, 还需要 p, 默认值为 1, 例如: https://www.bilibili.com/video/BV1Gb411T7mB?p=10 一个带有 p 参数的 bilibili 示例: {{\u003c bilibili BV1Gb411T7mB 10 \u003e}} 或者 {{\u003c bilibili id=BV1Gb411T7mB p=10 \u003e}} 呈现的输出效果如下: ","date":"2020-06-16","objectID":"https://betterrong.github.io/how-to-write-md/:7:0","tags":["markdown","hugo"],"title":"如何编写markdown（备份）","uri":"https://betterrong.github.io/how-to-write-md/"},{"categories":["documentation"],"content":"8 内容 ","date":"2020-06-16","objectID":"https://betterrong.github.io/how-to-write-md/:8:0","tags":["markdown","hugo"],"title":"如何编写markdown（备份）","uri":"https://betterrong.github.io/how-to-write-md/"},{"categories":["documentation"],"content":"内容摘要 默认情况下, Hugo 自动将内容的前 70 个单词作为摘要. 你可以通过在 网站配置 中设置 summaryLength 来自定义摘要长度. 如果您要使用 CJK中文/日语/韩语 语言创建内容, 并且想使用 Hugo 的自动摘要拆分功能，请在 网站配置 中将 hasCJKLanguage 设置为 true. 手动摘要拆分 另外, 你也可以添加 \u003c!--more--\u003e 摘要分割符来拆分文章生成摘要. 摘要分隔符之前的内容将用作该文章的摘要. 注意 请小心输入\u003c!--more--\u003e ; 即全部为小写且没有空格. 前置参数摘要 你可能希望摘要不是文章开头的文字，在这种情况下, 你可以在文章前置参数的 summary 变量中设置单独的摘要。 使用文章描述作为摘要 你可能希望将文章前置参数中的 description 变量的内容作为摘要. 你仍然需要在文章开头添加 \u003c!--more--\u003e 摘要分割符. 将摘要分隔符之前的内容保留为空. 然后 LoveIt主题会将你的文章描述作为摘要。 注意 不建议在摘要内容中包含富文本块元素, 这会导致渲染错误. 例如代码块, 图片, 表格等. ","date":"2020-06-16","objectID":"https://betterrong.github.io/how-to-write-md/:8:1","tags":["markdown","hugo"],"title":"如何编写markdown（备份）","uri":"https://betterrong.github.io/how-to-write-md/"},{"categories":["documentation"],"content":"9Markdown 扩展语法 LoveIt 主题提供了一些扩展的语法便于你撰写文章。 ","date":"2020-06-16","objectID":"https://betterrong.github.io/how-to-write-md/:9:0","tags":["markdown","hugo"],"title":"如何编写markdown（备份）","uri":"https://betterrong.github.io/how-to-write-md/"},{"categories":["documentation"],"content":"Emoji 支持 ","date":"2020-06-16","objectID":"https://betterrong.github.io/how-to-write-md/:9:1","tags":["markdown","hugo"],"title":"如何编写markdown（备份）","uri":"https://betterrong.github.io/how-to-write-md/"},{"categories":["documentation"],"content":"数学公式 LoveIt 基于 $ \\KaTeX $ 提供数学公式的支持. 在网站配置 中的 [params.math] 下面设置属性 enable = true, 并在文章的前置参数中设置属性 math: true来启用数学公式的自动渲染. 技巧 有一份 $ \\KaTeX $ 中支持的 $ \\TeX $ 函数 清单. 公式块 默认的公式块分割符是 $$/$$ 和 \\\\[/\\\\]: $$ c = \\pm\\sqrt{a^2 + b^2} $$ \\\\[ f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\\\] 呈现的输出效果如下: $$ c = \\pm\\sqrt{a^2 + b^2} $$ \\[ f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\] 行内公式 默认的行内公式分割符是 $/$ 和 \\\\(/\\\\): $ c = \\pm\\sqrt{a^2 + b^2} $ 和 \\\\( f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\\\) 呈现的输出效果如下: $ c = \\pm\\sqrt{a^2 + b^2} $ 和 \\( f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\) 技巧 可以在网站配置中自定义公式块和行内公式的分割符. Copy-tex Copy-tex 是一个 $ \\KaTeX $ 的插件. 通过这个扩展, 在选择并复制 $ \\KaTeX $ 渲染的公式时, 会将其 $ \\LaTeX $ 源代码复制到剪贴板. 在网站配置 中的 [params.math] 下面设置属性 copyTex = true 来启用 Copy-tex. 选择并复制上一节中渲染的公式, 可以发现复制的内容为 LaTeX 源代码. mhchem mhchem 是一个 $ \\KaTeX $ 的插件. 通过这个扩展, 可以在文章中轻松编写漂亮的化学方程式. 在你的网站配置中的 [params.math] 下面设置属性 mhchem = true 来启用 mhchem. $$ \\ce{CO2 + C -\u003e 2 CO} $$ $$ \\ce{Hg^2+ -\u003e[I-] HgI2 -\u003e[I-] [Hg^{II}I4]^2-} $$ 呈现的输出效果如下: $$ \\ce{CO2 + C -\u003e 2 CO} $$ $$ \\ce{Hg^2+ -\u003e[I-] HgI2 -\u003e[I-] [Hg^{II}I4]^2-} $$ ","date":"2020-06-16","objectID":"https://betterrong.github.io/how-to-write-md/:9:2","tags":["markdown","hugo"],"title":"如何编写markdown（备份）","uri":"https://betterrong.github.io/how-to-write-md/"},{"categories":["documentation"],"content":"字符注音或者注释 LoveIt 主题支持一种 字符注音或者注释 Markdown 扩展语法: [Hugo]^(一个开源的静态网站生成工具) 呈现的输出效果如下: Hugo一个开源的静态网站生成工具 ","date":"2020-06-16","objectID":"https://betterrong.github.io/how-to-write-md/:9:3","tags":["markdown","hugo"],"title":"如何编写markdown（备份）","uri":"https://betterrong.github.io/how-to-write-md/"},{"categories":["documentation"],"content":"分数 LoveIt 主题支持一种 分数 Markdown 扩展语法: [浅色]/[深色] [99]/[100] 呈现的输出效果如下: 浅色/深色 90/100 ","date":"2020-06-16","objectID":"https://betterrong.github.io/how-to-write-md/:9:4","tags":["markdown","hugo"],"title":"如何编写markdown（备份）","uri":"https://betterrong.github.io/how-to-write-md/"},{"categories":["documentation"],"content":"转义字符 详情请看转义字符 ","date":"2020-06-16","objectID":"https://betterrong.github.io/how-to-write-md/:9:5","tags":["markdown","hugo"],"title":"如何编写markdown（备份）","uri":"https://betterrong.github.io/how-to-write-md/"},{"categories":null,"content":"记录 《Essential C++》 《塔希里亚故事集Ⅱ》 ","date":"2020-06-11","objectID":"https://betterrong.github.io/reading/2005/:1:0","tags":null,"title":"仲夏","uri":"https://betterrong.github.io/reading/2005/"},{"categories":null,"content":"读后感 ","date":"2020-06-11","objectID":"https://betterrong.github.io/reading/2005/:2:0","tags":null,"title":"仲夏","uri":"https://betterrong.github.io/reading/2005/"},{"categories":null,"content":"1《Essential C++》 作者: [美] Stanley B·Lippman 自己的C++ 水平真的很烂，最近很想重新拾起c++。自己有一本《C++primer》，但是它写的太细致，又长又难。读过几章后，实在难以为继，这书作为工具书还行，用来自学太过艰难。无意间见到网上有人推荐 《Essential C++》这本书，虽然短小但是麻雀虽小，五脏俱全。该有的都有，网上的评价也很高。难度也还行，对于我这种学过c++但是水平略低并想要提高的人来说再合适不过了。 ","date":"2020-06-11","objectID":"https://betterrong.github.io/reading/2005/:2:1","tags":null,"title":"仲夏","uri":"https://betterrong.github.io/reading/2005/"},{"categories":null,"content":"2 《塔希里亚故事集》 作者：吴淼 这是一本别具一格的漫画，作者的这种风格我很喜欢。 “想做法师，哪怕是最蹩脚最愚蠢的法师，只要是法师就行了。” 想改变自己，哪怕是每天只改变一点点，只要每天在改变就行了。 ","date":"2020-06-11","objectID":"https://betterrong.github.io/reading/2005/:2:2","tags":null,"title":"仲夏","uri":"https://betterrong.github.io/reading/2005/"},{"categories":["literature"],"content":"尽管从未见过你的身影，我的大脑里却铭刻你的笑容。 尽管从未听过你的声音，我的热血中却澎湃你的激情。 在你离开的日子，我不理解父母为什么流了那么多的眼泪； 当歌颂你的红歌再次响遍神州，我才明白那是因为你的英明。 在淡化中，你的思想走向永恒； 在污水下，你的人格越发晶莹。 我不愿重叙你的伟大，这些连你的对手都不敢否认； 只想找出你的一些过错，只为爱你的人把思念稍稍减轻。 可是我实在很难做到这一点，不知我应该失望，还是应该高兴？ 你做的许多“错事”今天看来似乎都是对的， 是责怪你的人一次又一次地为你证明！ 你的担忧，今天正在成为现实， 你的警言，将迷醉的人们唤醒。 你粉碎了自己一世的英名， 将不灭的物质化成不朽的思想，溶进了追随者的心灵。 四十年了，你一天也没有走远，始终是恨你的人的噩梦； 他们千遍万遍地诅咒你，却永远没有勇气直对着你的眼睛！ 四十年了，你一直活在人民中间，始终是爱你的人的福星； 他们不用每天念叨着你，却每一分钟都能感受到你的柔情。 当我用“你”来称呼你的时候，我从来不觉得那是一种不敬—— 你是咱老百姓的领袖，也实实在在和我一样，是个普通百姓。 于是，你成了一道障碍，是颠覆者面前绕不过去的长城； 于是，你成了一把利剑，是信仰者手中克敌制胜的保证。 有人在偷偷地称量着自己的“成果”， 却总是无奈地看着不偏向自己的天平； 有人在暗暗地担忧着民族的前途， 却总能在黑夜中看到光明。 有人叹息，成为第二个苏联为何如此费力？ 有人骄傲，保卫社会主义这仗我们能赢！ 无奈和信心竟然如此对立统一，憎恨和敬仰竟然如此泾渭分明！ 这一切都是因为有了你—— 一个中国农民的儿子，一个东方民族的英雄！ 我无缘与你相识，却可与你彻夜长谈； 我与你两界相隔，却总与你心灵相同。 我愿意轻轻地告诉你： 毛泽东，我的导师，你的思想将伴随我的一生！ ","date":"2020-06-06","objectID":"https://betterrong.github.io/we-ardently-love-you/:0:0","tags":["文学","毛主席"],"title":"尽管从未见过你的身影","uri":"https://betterrong.github.io/we-ardently-love-you/"},{"categories":["literature"],"content":" 读六月三十日《人民日报》，余江县消灭了血吸虫。浮想联翩， 夜不能寐。微风拂煦，旭日临窗。遥望南天，欣然命笔。 ","date":"2020-01-26","objectID":"https://betterrong.github.io/chairman-mao-sswfuf/:0:0","tags":["文学","毛主席"],"title":"毛泽东《七律二首·送瘟神》","uri":"https://betterrong.github.io/chairman-mao-sswfuf/"},{"categories":["literature"],"content":"其一 绿水青山枉自多，华佗无奈小虫何！ 千村薜荔人遗矢，万户萧疏鬼唱歌。 坐地日行八万里，巡天遥看一千河。 牛郎欲问瘟神事，一样悲欢逐逝波。 ","date":"2020-01-26","objectID":"https://betterrong.github.io/chairman-mao-sswfuf/:1:0","tags":["文学","毛主席"],"title":"毛泽东《七律二首·送瘟神》","uri":"https://betterrong.github.io/chairman-mao-sswfuf/"},{"categories":["literature"],"content":"其二 春风杨柳万千条，六亿神州尽舜尧。 红雨随心翻作浪，青山着意化为桥。 天连五岭银锄落，地动三河铁臂摇。 借问瘟君欲何往，纸船明烛照天烧。 毛主席《七律二首·送瘟神》手迹 ","date":"2020-01-26","objectID":"https://betterrong.github.io/chairman-mao-sswfuf/:2:0","tags":["文学","毛主席"],"title":"毛泽东《七律二首·送瘟神》","uri":"https://betterrong.github.io/chairman-mao-sswfuf/"},{"categories":["documentation"],"content":"glob 模式（globbing）也被称之为 shell 通配符，名字的起源来自于 Unix V6 中的 /etc/glob （详见 man 文档）。","date":"2020-01-24","objectID":"https://betterrong.github.io/glob-use/","tags":["shell","glob"],"title":"glob文件匹配模式","uri":"https://betterrong.github.io/glob-use/"},{"categories":["documentation"],"content":"0x00 简介 注意 shell 通配符 / glob 模式通常用来匹配目录以及文件，而不是文本！！！ ","date":"2020-01-24","objectID":"https://betterrong.github.io/glob-use/:1:0","tags":["shell","glob"],"title":"glob文件匹配模式","uri":"https://betterrong.github.io/glob-use/"},{"categories":["documentation"],"content":"0x01 语法和使用 ","date":"2020-01-24","objectID":"https://betterrong.github.io/glob-use/:2:0","tags":["shell","glob"],"title":"glob文件匹配模式","uri":"https://betterrong.github.io/glob-use/"},{"categories":["documentation"],"content":"通配符(wild matching) *匹配0或多个任意数量字符，包括空字符。 例： like* #可匹配：likeq,likebetter,like07,like *like* #可匹配：ilikeyou,helikeshe,TomlikeMary,like ?可匹配任意一个字符。 例: ?est #可匹配：west,test,Rest,pest等等 #不可匹配:est ","date":"2020-01-24","objectID":"https://betterrong.github.io/glob-use/:2:1","tags":["shell","glob"],"title":"glob文件匹配模式","uri":"https://betterrong.github.io/glob-use/"},{"categories":["documentation"],"content":"字符集(Character Classes) [abc]可匹配任意一个[]包含的字符。 例： [rtW]est #只可以匹配：rest或test或West。 ","date":"2020-01-24","objectID":"https://betterrong.github.io/glob-use/:2:2","tags":["shell","glob"],"title":"glob文件匹配模式","uri":"https://betterrong.github.io/glob-use/"},{"categories":["documentation"],"content":"字符范围（Range) [a-z]匹配任意一个给定范围的字符： 例： a[0-9] #可匹配：a0,a1,a2等等 #不可匹配：aa,a,a11 注意：如果-出现在开头或结尾，并不表示范围，如[-a]或[a-]，表示匹配字符a或-。 ","date":"2020-01-24","objectID":"https://betterrong.github.io/glob-use/:2:3","tags":["shell","glob"],"title":"glob文件匹配模式","uri":"https://betterrong.github.io/glob-use/"},{"categories":["documentation"],"content":"字符取反（Complementation） !排除，如[!abc]、[!a-z]不匹配任意一个[]包含或给定范围的字符。 例： [!rt]est #可匹配：west,pest等等， #不可匹配：rest、test 例： test[!5-8] # 可匹配：test1,test2,test9 #不可匹配：test5,test6,test7,test8 ","date":"2020-01-24","objectID":"https://betterrong.github.io/glob-use/:2:4","tags":["shell","glob"],"title":"glob文件匹配模式","uri":"https://betterrong.github.io/glob-use/"},{"categories":["documentation"],"content":"专用字符集 字符 意义 [:alnum:] 任意数字或者字母 [:alpha:] 任意字母 [:space:] 空格 [:lower:] 小写字母 [:digit:] 任意数字 [:upper:] 任意大写字母 [:cntrl:] 控制符 [:graph:] 图形 [:print:] 可打印字符 [:punct:] 标点符号 [:xdigit:] 十六进制数 [:blank:] 空白字符（未验证） ","date":"2020-01-24","objectID":"https://betterrong.github.io/glob-use/:2:5","tags":["shell","glob"],"title":"glob文件匹配模式","uri":"https://betterrong.github.io/glob-use/"},{"categories":["documentation"],"content":"扩展 上面所有形式的glob都不可以匹配路径分隔符（linux中的/，windows中的\\）。 例： *.txt #不可匹配：dir1/test.txt,dir2/dir21/test.txt **匹配任意数量的字符包括空字符（包括路径分隔符）,即可匹配0或多个子文件夹。 例： **/*.txt #可匹配a/b/c/t.txt,a/s.txt 任何以.开头命名的文件，都必须在glob中显示指定才能匹配。 例： #.abc用 * #匹配不到,必须用 .* #匹配。 glob与正则表达式不同，glob只匹配路径名，不匹配文件内容。 glob尝试匹配整个字符串（例：S*.doc将匹配S.doc和SA.doc但不匹配POST.doc或SURREY.docks）正则要只匹配子串须使用^和$所以，S*.doc等价正则是^S.*\\.doc$ ","date":"2020-01-24","objectID":"https://betterrong.github.io/glob-use/:2:6","tags":["shell","glob"],"title":"glob文件匹配模式","uri":"https://betterrong.github.io/glob-use/"},{"categories":["documentation"],"content":"0x02 示例 这里使用 /etc 下的文件为例 匹配以 a开头，中间包含任意数量数字的文件 ls a*[0-9]* #当然你是找不到的，因为通常情况下 /etc 下没有这样的文件 匹配以任意小写字母开头，中间包含数字的文件 ls [[:lower:]]*[0-9]* #相信你已经看到了一些文件，我们继续 列出所有文件中以 init 开头，英文结尾的文件 ls init*[a-z] 列出以 au,b,c 开头的文件 ls {\"au\",[bc]}* ","date":"2020-01-24","objectID":"https://betterrong.github.io/glob-use/:3:0","tags":["shell","glob"],"title":"glob文件匹配模式","uri":"https://betterrong.github.io/glob-use/"},{"categories":["documentation"],"content":"0x03 注意事项 在使用专属字符集的时候，字符集之外还需要用 [ ] 来包含住，否则专用字符集不会生效，例如 [[:space:]]。 想要转义的时候，单引号与双引号使用方法是不同的，单引号会转义所有字符，而且单引号中间不允许再出现单引号，双引号允许出现特定的 shell 元字符，具体字符可以自行查询。 在使用花括号 {} 的时候，里面的单个字符串需要使用单引号或者双引号括住，否则就会视为多个的单个字符。 ","date":"2020-01-24","objectID":"https://betterrong.github.io/glob-use/:4:0","tags":["shell","glob"],"title":"glob文件匹配模式","uri":"https://betterrong.github.io/glob-use/"},{"categories":["documentation"],"content":"0x04 参考 Glob匹配模式 glob模式 ","date":"2020-01-24","objectID":"https://betterrong.github.io/glob-use/:5:0","tags":["shell","glob"],"title":"glob文件匹配模式","uri":"https://betterrong.github.io/glob-use/"}]