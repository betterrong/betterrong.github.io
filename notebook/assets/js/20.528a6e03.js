(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{365:function(s,a,t){"use strict";t.r(a);var e=t(42),n=Object(e.a)({},(function(){var s=this,a=s.$createElement,t=s._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[t("h1",{attrs:{id:"gcc-使用指北"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#gcc-使用指北"}},[s._v("#")]),s._v(" gcc 使用指北")]),s._v(" "),t("h2",{attrs:{id:"_0x01-简介"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_0x01-简介"}},[s._v("#")]),s._v(" 0x01 简介")]),s._v(" "),t("p",[s._v("gcc 是 "),t("strong",[s._v("GNU C Complier")]),s._v(" 的缩写。 GNU 推出的多平台编译器，经过这些年不断的迭代，GCC 的功能得到了很大的扩展，它不仅可以用来编译 C 语言程序，还可以处理 C++、Go、Objective -C 等多种编译语言编写的程序。与此同时，由于之前的 GNU C Compiler 已经无法完美诠释 GCC 的含义，所以其英文全称被重新定义为 "),t("strong",[s._v("GNU Compiler Collection")]),s._v("，即 GNU 编译器套件。")]),s._v(" "),t("h2",{attrs:{id:"_0x02-快速入门"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_0x02-快速入门"}},[s._v("#")]),s._v(" 0x02 快速入门")]),s._v(" "),t("p",[s._v("gcc 编译有四个步骤：")]),s._v(" "),t("p",[s._v("预处理、编译、汇编、链接。")]),s._v(" "),t("p",[s._v("编译工具链：预处理器 cpp、编译器gcc、汇编器 as、链接器 ld。")]),s._v(" "),t("h3",{attrs:{id:"_2-1-一步编译"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-一步编译"}},[s._v("#")]),s._v(" 2.1 一步编译")]),s._v(" "),t("div",{staticClass:"language-c line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-c"}},[t("code",[t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("//hello.c")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token macro property"}},[s._v("#"),t("span",{pre:!0,attrs:{class:"token directive keyword"}},[s._v("include")]),t("span",{pre:!0,attrs:{class:"token string"}},[s._v("<stdio.h>")])]),s._v("\n\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("int")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("main")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("void")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("printf")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token string"}},[s._v('"Hello,world!"')]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n    \n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("return")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("0")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br"),t("span",{staticClass:"line-number"},[s._v("8")]),t("br")])]),t("p",[s._v("简单编译：")]),s._v(" "),t("div",{staticClass:"language-sh line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-sh"}},[t("code",[s._v("gcc hello.c\n//生成可执行文件 a.out\n./a.out\n//运行\nHello,world"),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("!")]),s._v("\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br")])]),t("h3",{attrs:{id:"_2-2-编译选项"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-编译选项"}},[s._v("#")]),s._v(" 2.2 编译选项")]),s._v(" "),t("ul",[t("li",[s._v("-E  预处理指定的源文件，不进行编译。")]),s._v(" "),t("li",[s._v("-S  编译指定的源文件，但是不进行汇编。")]),s._v(" "),t("li",[s._v("-c    编译、汇编指定的源文件，但是不进行链接。")]),s._v(" "),t("li",[s._v("-o    指定生成文件的文件名。")]),s._v(" "),t("li",[s._v("-ansi   对于 C 语言程序来说，其等价于 -std=c90；对于 C++ 程序来说，其等价于 -std=c++98。")]),s._v(" "),t("li",[s._v("-llibrary（-I library)  其中 library 表示要搜索的库文件的名称。该选项用于手动指定链接环节中程序可以调用的库文件。建议 -l 和库文件名之间不使用空格，比如 -lstdc++。")]),s._v(" "),t("li",[s._v("-std=   手动指令编程语言所遵循的标准，例如 c89、c90、c++98、c++11 等。")])]),s._v(" "),t("h3",{attrs:{id:"_2-3-e-对源程序做预处理操作"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-e-对源程序做预处理操作"}},[s._v("#")]),s._v(" 2.3  -E 对源程序做预处理操作")]),s._v(" "),t("p",[s._v("通过为 gcc 指令添加 -E 选项，即可控制 GCC 编译器仅对源代码做预处理操作。预处理操作，主要是处理那些源文件和头文件中以 # 开头的命令（比如 #include、#define、#ifdef 等），并删除程序中所有的注释 // 和 /* ... */。")]),s._v(" "),t("p",[s._v("默认情况下 gcc -E 指令只会将预处理操作的结果输出到屏幕上，并不会自动保存到某个文件。因此该指令往往会和 -o 选项连用，将结果导入到指令的文件中。")]),s._v(" "),t("div",{staticClass:"language-sh line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-sh"}},[t("code",[s._v("gcc -E -o demo.i demo.c\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br")])]),t("h3",{attrs:{id:"_2-4-s-编译非汇编文件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-4-s-编译非汇编文件"}},[s._v("#")]),s._v(" 2.4 -S  编译非汇编文件")]),s._v(" "),t("p",[s._v("编译是整个程序构建的核心部分，也是最复杂的部分之一。")]),s._v(" "),t("p",[s._v("通过给 gcc 指令添加 -S（注意是大写）选项，即可令 GCC 编译器仅将指定文件加工至编译阶段，并生成对应的汇编代码文件。")]),s._v(" "),t("div",{staticClass:"language-sh line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-sh"}},[t("code",[s._v("gcc -E -o test.s test.i\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br")])]),t("p",[s._v("gcc -S 指令操作的文件并非必须是经过预处理后得到的 .i 文件，-S 选项的功能是令 GCC 编译器将指定文件处理至编译阶段结束。这也就意味着，gcc -S 指令可以操作预处理后的 .i 文件，也可以操作源代码文件：")]),s._v(" "),t("ul",[t("li",[s._v("如果操作对象为 .i 文件，则 GCC 编译器只需编译此文件；")]),s._v(" "),t("li",[s._v("如果操作对象为 .c 或者 .cpp 源代码文件，则 GCC 编译器会对其进行预处理和编译这 2 步操作。")])]),s._v(" "),t("h3",{attrs:{id:"_2-5-c-生成目标文件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-5-c-生成目标文件"}},[s._v("#")]),s._v(" 2.5 -c 生成目标文件")]),s._v(" "),t("p",[s._v("汇编其实就是将汇编代码转换成可以执行的机器指令。")]),s._v(" "),t("p",[s._v("gcc 指令添加 -c 选项（注意是小写字母 c），即可让 GCC 编译器将指定文件加工至汇编阶段，并生成相应的目标文件。")]),s._v(" "),t("div",{staticClass:"language-sh line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-sh"}},[t("code",[s._v("gcc -c -o "),t("span",{pre:!0,attrs:{class:"token builtin class-name"}},[s._v("test")]),s._v(" test.s\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br")])]),t("p",[s._v("和 gcc -S 类似，gcc -c 选项并非只能用于加工 .s 文件。事实上，-c 选项只是令 GCC 编译器将指定文件加工至汇编阶段，但不执行链接操作。")]),s._v(" "),t("h3",{attrs:{id:"_2-6-o-指定输出文件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-6-o-指定输出文件"}},[s._v("#")]),s._v(" 2.6 -o 指定输出文件")]),s._v(" "),t("p",[s._v("gcc "),t("code",[s._v("-o")]),s._v(" 选项用来指定输出文件，如果不使用 -o 选项，那么将采用默认的输出文件。例如默认情况下，生成的可执行文件的名字默认为 a.out。")]),s._v(" "),t("p",[s._v("如下是 gcc -o 指令的使用语法格式：")]),s._v(" "),t("p",[s._v("gcc [-E|-S|-c] [infile] [-o outfile]")]),s._v(" "),t("blockquote",[t("p",[s._v("其中，用方括号 [] 括起来的部分可以忽略。")])]),s._v(" "),t("p",[s._v("[infile] 表示输入文件（也即要处理的文件），它可以是源文件、汇编文件或者目标文件；[outfile] 表示输出文件（也即处理的结果），可以是预处理文件、目标文件、可执行文件等。")]),s._v(" "),t("p",[s._v("值得一提的是，通常情况下 [infile] 处放置一个文件，但根据实际需要也可以放置多个文件，表示有多个输入文件（后续会给出实例）。")]),s._v(" "),t("h3",{attrs:{id:"_2-7-wall-打开警告信息"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-7-wall-打开警告信息"}},[s._v("#")]),s._v(" 2.7 -Wall 打开警告信息")]),s._v(" "),t("p",[s._v("警告选项，它基本打开了所有需要注意的警告信息，比如没有指定类型的声明、在声明之前使用的函数、局部变量除了声明就没再使用等。")]),s._v(" "),t("h2",{attrs:{id:"_0x03-更多选项"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_0x03-更多选项"}},[s._v("#")]),s._v(" 0x03 更多选项")]),s._v(" "),t("h3",{attrs:{id:"_3-1-o-或-o1-优化选项"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-o-或-o1-优化选项"}},[s._v("#")]),s._v(" 3.1 -O 或 - O1 优化选项")]),s._v(" "),t("p",[s._v("对于大函数，优化编译的过程将占用较长时间和相当大的内存。优化得到的程序比没优化的要小。不适用 - O 选项的目的是减少编译的开销，使编译结果能够调试、语句是独立的。 -O2 是多优化一些，最常使用。这个选项既增加了编译时间，也提高了生成代码的运行效果。-O0 是不优化。")]),s._v(" "),t("ul",[t("li",[t("code",[s._v("-O")]),s._v(" 线程跳转和延迟退栈两种优化")]),s._v(" "),t("li",[t("code",[s._v("-O2")]),s._v(" 处理器指令调度")]),s._v(" "),t("li",[t("code",[s._v("-O3")]),s._v("循环展开和其他一些与处理器特性相关的优化工作")]),s._v(" "),t("li",[s._v("数字越大，编译时间越长，优化越好。")]),s._v(" "),t("li",[s._v("优化可以加快代码运行速度，但不利于调试。建议最终发行的时候再优化。")])]),s._v(" "),t("h3",{attrs:{id:"_3-2-gcc-编译多文件项目"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-gcc-编译多文件项目"}},[s._v("#")]),s._v(" 3.2  GCC 编译多文件项目")]),s._v(" "),t("div",{staticClass:"language-sh line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-sh"}},[t("code",[s._v("gcc -c myfun.c main.c\ngcc *.c -o main\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br")])]),t("h3",{attrs:{id:"_3-3-time-命令"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-time-命令"}},[s._v("#")]),s._v(" 3.3 time 命令")]),s._v(" "),t("div",{staticClass:"language-sh line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-sh"}},[t("code",[t("span",{pre:!0,attrs:{class:"token function"}},[s._v("time")]),s._v(" ./main\nreal      0m1.007s 进程运行总时长\nuser\t  0m1.007s 进程在用户态所用时长\nsys \t  0m1.007s 进程在内核态所用时长\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br")])]),t("h3",{attrs:{id:"_3-4-库文件连接"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-4-库文件连接"}},[s._v("#")]),s._v(" 3.4 库文件连接")]),s._v(" "),t("h4",{attrs:{id:"_1-介绍"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-介绍"}},[s._v("#")]),s._v(" 1 介绍")]),s._v(" "),t("p",[s._v("函数库实际上就是一些"),t("strong",[s._v("头文件")]),s._v("（.h）和"),t("strong",[s._v("库文件")]),s._v("（so、或 lib、dll）的集合。虽然 Linux 下的大多数函数都默认将头文件放到"),t("code",[s._v("/usr/include/")]),s._v("目录下，而库文件则放到 "),t("code",[s._v("/usr/lib/")]),s._v(" 目录下；Windows 所使用的库文件主要放在 Visual Stido 的目录下的 include 和 lib，以及系统文件夹下。但也有的时候，我们要用的库不再这些目录下，所以 GCC 在编译时必须用自己的办法来查找所需要的头文件和库文件。")]),s._v(" "),t("p",[s._v("共享库的后缀名由 "),t("code",[s._v(".so")]),s._v("和版本号组成。静态库的后缀名为"),t("code",[s._v(".a")]),s._v("。静态库的代码在"),t("strong",[s._v("编译时")]),s._v("就已经链接到开发人员的程序中，而共享库是程序"),t("strong",[s._v("运行时")]),s._v("才加载。")]),s._v(" "),t("p",[s._v("当把程序链接到一个链接库时，只会链接程序所用到的函数的目标文件。在已编译的目标文件之外，如果创建自己的链接库，可以使用 ar 命令。")]),s._v(" "),t("p",[s._v("标准库的大部分函数通常放在文件 libc.a 中，或者放在用于共享的动态链接文件 libc.so 中（文件名后缀"),t("code",[s._v(".so")]),s._v(" 代表 “share object”，译为 “共享对象”）。这些链接库一般位于"),t("code",[s._v("/lib/")]),s._v("或 "),t("code",[s._v("/usr/lib/")]),s._v("，或者位于 "),t("a",{attrs:{href:"http://c.biancheng.net/gcc/",target:"_blank",rel:"noopener noreferrer"}},[s._v("GCC"),t("OutboundLink")],1),s._v(" 默认搜索的其他目录。")]),s._v(" "),t("p",[t("code",[s._v("-l")]),s._v(" 选项（小写的 L）可以让我们手动添加链接库。")]),s._v(" "),t("div",{staticClass:"language-sh line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-sh"}},[t("code",[s._v("gcc main.c -o main.out -lm\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br")])]),t("p",[s._v("数学库的文件名是 libm.a。前缀 "),t("code",[s._v("lib")]),s._v(" 和后缀"),t("code",[s._v(".a")]),s._v(" 是标准的，"),t("code",[s._v("m")]),s._v(" 是基本名称，GCC 会在 "),t("code",[s._v("-l")]),s._v(" 选项后紧跟着的基本名称的基础上自动添加这些前缀、后缀，本例中，基本名称为 m。")]),s._v(" "),t("h4",{attrs:{id:"_2-相关路径选项"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-相关路径选项"}},[s._v("#")]),s._v(" 2 相关路径选项")]),s._v(" "),t("ul",[t("li",[t("p",[t("code",[s._v("-I <dir>")]),s._v("gcc使用缺省的路径来搜索"),t("strong",[s._v("头文件")]),s._v("，如果想改变搜索路径，使用"),t("code",[s._v("-I")]),s._v("选项，可以在头文件的搜索路径列表中添加"),t("code",[s._v("<dir>")]),s._v(" 目录。这样就可以去指定目录寻找头文件。")]),s._v(" "),t("div",{staticClass:"language-c line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-c"}},[t("code",[t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("//hello.c")]),s._v("\ninclude"),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("<")]),s._v("my"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("h"),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("int")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("main")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("int")]),s._v(" argc"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("char")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v("argv"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("printf")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token string"}},[s._v('"Hello!\\n"')]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("return")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("0")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("//my.h")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token macro property"}},[s._v("#"),t("span",{pre:!0,attrs:{class:"token directive keyword"}},[s._v("include")]),t("span",{pre:!0,attrs:{class:"token string"}},[s._v("<stdio.h>")])]),s._v("\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br"),t("span",{staticClass:"line-number"},[s._v("8")]),t("br")])]),t("p",[s._v("通过以下命令链接头文件：")]),s._v(" "),t("div",{staticClass:"language-sh line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-sh"}},[t("code",[s._v("gcc -I./include -o hello hello.c \n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br")])]),t("p",[s._v("也可以写成这样：")]),s._v(" "),t("div",{staticClass:"language-c line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-c"}},[t("code",[t("span",{pre:!0,attrs:{class:"token macro property"}},[s._v("#"),t("span",{pre:!0,attrs:{class:"token directive keyword"}},[s._v("include")]),t("span",{pre:!0,attrs:{class:"token string"}},[s._v('"./include/my.h"')])]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("int")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("main")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("int")]),s._v(" argc"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("char")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v("argv"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n  "),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("printf")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token string"}},[s._v('"Hello!\\n"')]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n\n  "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("return")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("0")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br")])]),t("div",{staticClass:"language-sh line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-sh"}},[t("code",[s._v("gcc -o hello hello.c\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br")])]),t("p",[s._v("include 语句中，"),t("code",[s._v("<>")]),s._v(" 表示在标准路径搜索头文件，Linux 中默认为 "),t("code",[s._v("/usr/include/")])]),s._v(" "),t("blockquote",[t("p",[s._v('c/c++ 中 #include <> 与 #include"" 区别')]),s._v(" "),t("p",[s._v("<> 先去系统目录中找头文件，如果没有在到当前目录下找。所以像标准的头文件 stdio.h、stdlib.h 等用这个方法。")]),s._v(" "),t("p",[s._v('而 "" 首先在当前目录下寻找，如果找不到，再到系统目录中寻找。 这个用于 include 自定义的头文件，让系统优先使用当前目录中定义的。')])])])]),s._v(" "),t("p",[s._v("gcc 寻找头文件的路径 (按照 1->2->3 的顺序)")]),s._v(" "),t("ol",[t("li",[t("p",[s._v("在 gcc 编译源文件的时候，通过参数 - I 指定头文件的搜索路径，如果指定路径有多个路径时，则按照指定路径的顺序搜索头文件。命令形式如：“gcc -I /path/where/theheadfile/in sourcefile.c“，这里源文件的路径可以是绝对路径，也可以是相对路径。设当前路径为 /root/test，include_test.c 如果要包含头文件 “include_test.h“，有两种方法：")]),s._v(" "),t("ul",[t("li",[s._v("include_test.c 中 "),t("code",[s._v("#include “include/include_test.h”")]),s._v("或者 "),t("code",[s._v('#include "/root/test/include/include_test.h"')]),s._v("，然后 gcc include_test.c 即可")]),s._v(" "),t("li",[s._v("include_test.c 中 "),t("code",[s._v("#include <include_test.h>")]),s._v(" 或者"),t("code",[s._v("#include “include_test.h”")]),s._v("，然后 "),t("code",[s._v("gcc –I include include_test.c")]),s._v("也可。")])])]),s._v(" "),t("li",[t("p",[s._v("通过查找 gcc 的环境变量 C_INCLUDE_PATH/CPLUS_INCLUDE_PATH/OBJC_INCLUDE_PATH 来搜索头文件位置。")])]),s._v(" "),t("li",[t("p",[s._v("再找内定目录搜索，分别是")])])]),s._v(" "),t("p",[t("code",[s._v("/usr/include")])]),s._v(" "),t("p",[t("code",[s._v("/usr/local/include")])]),s._v(" "),t("p",[t("code",[s._v("/usr/lib/gcc-lib/i386-linux/2.95.2/include")])]),s._v(" "),t("p",[s._v("最后一行是 gcc 程序的库文件地址，各个用户的系统上可能不一样。")]),s._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[s._v("  gcc 在默认情况下，都会指定到 /usr/include 文件夹寻找头文件。\n")])])]),t("ul",[t("li",[t("p",[t("code",[s._v("-L<dir>")]),s._v("与"),t("code",[s._v("-I <dir>")]),s._v("类似，区别就是 "),t("code",[s._v("-L")]),s._v("是用于指明库文件的路径。")]),s._v(" "),t("p",[s._v("例如 hello.c 需要用到 "),t("code",[s._v("/root/workspace/gcc/lib")]),s._v(" 下的一个动态库libsunq.so，则命令如下：")]),s._v(" "),t("div",{staticClass:"language-sh line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-sh"}},[t("code",[s._v("gcc -o hello -L/root/workspace/gcc/lib -lsunq  hello.c\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br")])]),t("p",[s._v("可以使用多个 "),t("code",[s._v("-L")]),s._v(" 选项，或者在一个 "),t("code",[s._v("-L")]),s._v(" 选项内使用冒号分割的路径列表。")])]),s._v(" "),t("li",[t("p",[s._v("使用不同类型链接库")]),s._v(" "),t("p",[s._v("由于在Linux中函数库的命名规则都是以"),t("code",[s._v("lib")]),s._v("开头的，因此库文件只需填写lib之后的内容即可。")]),s._v(" "),t("p",[s._v("如果有静态链接库文件 "),t("code",[s._v("libm.a")]),s._v(" 调用时写成 "),t("code",[s._v("-lm")]),s._v("即可。同样对于 "),t("code",[s._v("libm.so")]),s._v(" 调用时也写成 "),t("code",[s._v("-lm")])]),s._v(" "),t("div",{staticClass:"language-sh line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-sh"}},[t("code",[s._v("gcc -L/root/testc/lib/ -lmydynamic -o dynamic dynamic.o \n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br")])]),t("p",[s._v("同时存在库名相同的静态库和动态库时，")]),s._v(" "),t("p",[s._v("默认采用动态库链接。如果要链接静态库 在 "),t("code",[s._v("-l")]),s._v(" 前加上 "),t("code",[s._v("-static")])]),s._v(" "),t("div",{staticClass:"language-sh line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-sh"}},[t("code",[s._v("gcc -L/root/testc/lib/ -static -lmydynamic -o dynamic dynamic.o \n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br")])])])]),s._v(" "),t("h2",{attrs:{id:"_0x04-静态连接库和动态链接库的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_0x04-静态连接库和动态链接库的区别"}},[s._v("#")]),s._v(" 0x04 静态连接库和动态链接库的区别")]),s._v(" "),t("p",[s._v("静态链接库与动态链接库都是共享代码的方式。")]),s._v(" "),t("p",[s._v("区别：如果采用静态链接库，则无论你愿不愿意，lib 中的指令都全部被直接包含在最终生成的 EXE 文件中了。静态库的代码在编译过程中已经被载入可执行程序，因此体积较大。但是若使用 DLL，该 DLL 不必被包含在最终 EXE 文件中，EXE 文件执行时可以 “动态” 地引用和卸载这个与 EXE 独立的 DLL 文件。共享库的代码是在可执行程序运行时才载入内存的，在编译过程中仅简单的引用，因此代码体积较小。")]),s._v(" "),t("p",[s._v("​    静态链接库和动态链接库的另外一个区别在于静态链接库中"),t("strong",[s._v("不能再包含其他的动态链接库或者静态库")]),s._v("，而在动态链接库中还可以再包含其他的动态或静态链接库。")]),s._v(" "),t("p",[s._v("注意：在 window 下的动态链接：后缀为 dll；而 linux 下多为.so")]),s._v(" "),t("p",[s._v("所谓静态、动态是指链接。回顾一下，将一个程序编译成可执行程序的步骤：")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://s1.ax1x.com/2020/08/03/adWFte.png",alt:"adWFte.png"}})]),s._v(" "),t("h3",{attrs:{id:"_4-1-静态库"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-静态库"}},[s._v("#")]),s._v(" 4.1 静态库")]),s._v(" "),t("p",[s._v("之所以成为【静态库】，"),t("strong",[s._v("是因为在链接阶段，会将汇编生成的目标文件")]),s._v("**.o 与引用到的库一起链接打包到可执行文件中。因此对应的链接方式称为静态链接。**")]),s._v(" "),t("p",[s._v("在项目开发过程中，经常出现优秀代码重用现象，又或者提供给第三方功能模块却又不想让其看到源代码，这些时候，通常的做法是将代码封装成库或者框架，生成的静态库要和头文件同时发布。")]),s._v(" "),t("p",[s._v("试想一下，静态库与汇编生成的目标文件一起链接为可执行文件，"),t("strong",[s._v("那么静态库必定跟")]),s._v("**.o** "),t("strong",[s._v("文件格式相似")]),s._v("。其实一个静态库可以简单看成是"),t("strong",[s._v("一组目标文件（****.o/.obj")]),s._v(" "),t("strong",[s._v("文件）的集合")]),s._v("，即很多目标文件经过压缩打包后形成的一个文件。静态库特点总结：")]),s._v(" "),t("p",[t("strong",[s._v("优点：")])]),s._v(" "),t("ul",[t("li",[s._v("寻址方便，速度快")]),s._v(" "),t("li",[s._v("库在链接时被打包到可执行文件中，直接发布可执行程序即可以使用")])]),s._v(" "),t("p",[t("strong",[s._v("l  静态库对函数库的链接是放在编译时期完成的。")])]),s._v(" "),t("p",[t("strong",[s._v("l  程序在运行时与函数库再无瓜葛，移植方便。")])]),s._v(" "),t("p",[t("strong",[s._v("l  浪费空间和资源，因为所有相关的目标文件与牵涉到的函数库被链接合成一个可执行文件。")])]),s._v(" "),t("h4",{attrs:{id:"_4-1-1-linux-下创建与使用静态链接库"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-1-linux-下创建与使用静态链接库"}},[s._v("#")]),s._v(" 4.1.1 Linux 下创建与使用静态链接库")]),s._v(" "),t("ul",[t("li",[t("p",[s._v("命名规范")]),s._v(" "),t("p",[s._v('Linux 静态库命名规范，必须是 "lib [your_library_name].a"：lib 为前缀，中间是静态库名，扩展名为.a。')])]),s._v(" "),t("li",[t("p",[s._v("创建静态库过程")]),s._v(" "),t("ol",[t("li",[t("p",[s._v("将代码文件编译成目标文件.o")]),s._v(" "),t("div",{staticClass:"language-sh line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-sh"}},[t("code",[s._v("gcc -c *.c -I "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("..")]),s._v("/include\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br")])])]),s._v(" "),t("li",[t("p",[s._v("通过 ar 工具将目标文件打包成.a 静态库文件")]),s._v(" "),t("div",{staticClass:"language-sh line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-sh"}},[t("code",[s._v("ar rcs libhello.a *.o        将所有.o文件打包为静态库，r将文件插入静态库中，c创建静态库，不管库是否存在，s写入一个目标文件索引到库中，或者更新一个存在的目标文件索引。\n"),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("mv")]),s._v(" ibhello.a "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("..")]),s._v("/lib         将静态库文件放置lib文件夹下\nnm ibhello.a                查看库中包含的函数等信息\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br")])])])])])]),s._v(" "),t("p",[s._v("静态库使用")]),s._v(" "),t("div",{staticClass:"language-sh line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-sh"}},[t("code",[s._v("gcc + 源文件 + -L 静态库路径 + -l静态库名 + -I头文件目录 + -o 可执行文件名\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br")])]),t("ul",[t("li",[t("p",[s._v("动态库")]),s._v(" "),t("p",[s._v("静态库，容易使用和理解，也达到了代码复用的目的，那为什么还需要动态库呢？")]),s._v(" "),t("p",[s._v("空间浪费是静态库的一个问题。")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://s1.ax1x.com/2020/08/04/adxLNQ.jpg",alt:"adxLNQ.jpg"}})]),s._v(" "),t("p",[s._v("另一个问题是静态库对程序的更新、部署和发布页会带来麻烦。如果静态库 liba.lib 更新了，所以使用它的应用程序都需要重新编译、发布给用户（对于用户来说，可能是一个很小的改动，却导致整个程序重新下载，"),t("strong",[s._v("全量更新")]),s._v("）。")]),s._v(" "),t("p",[s._v("动态库在程序编译时并不会被连接到目标代码中，而是在程序运行是才被载入。"),t("strong",[s._v("不同的应用程序如果调用相同的库，那么在内存里只需要有一份该共享库的实例")]),s._v("，规避了空间浪费问题。动态库在程序运行是才被载入，也解决了静态库对程序的更新、部署和发布页会带来麻烦。用户只需要更新动态库即可，"),t("strong",[s._v("增量更新")]),s._v("。")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://s1.ax1x.com/2020/08/04/adxv3n.jpg",alt:"adxv3n.jpg"}})]),s._v(" "),t("p",[s._v("动态库特点总结：")]),s._v(" "),t("p",[s._v("l  动态库把对一些库函数的链接载入推迟到程序运行的时期。")]),s._v(" "),t("p",[s._v("l  可以实现进程之间的资源共享。（因此动态库也称为共享库）")]),s._v(" "),t("p",[s._v("l  将一些程序升级变得简单。")]),s._v(" "),t("p",[s._v("l  甚至可以真正做到链接载入完全由程序员在程序代码中控制（"),t("strong",[s._v("显示调用")]),s._v("）。")]),s._v(" "),t("p",[s._v("Window 与 Linux 执行文件格式不同，在创建动态库的时候有一些差异。")]),s._v(" "),t("p",[s._v("l  在 Windows 系统下的执行文件格式是 PE 格式，动态库需要一个 "),t("strong",[s._v("DllMain")]),s._v(" "),t("strong",[s._v("函数做出初始化的入口，通常在导出函数的声明时需要有_declspec (dllexport)")]),s._v(" "),t("strong",[s._v("关键字")]),s._v("。")]),s._v(" "),t("p",[s._v("l  Linux 下 gcc 编译的执行文件默认是 ELF 格式，**不需要初始化入口，亦不需要函数做特别的声明，**编写比较方便。")]),s._v(" "),t("p",[s._v("与创建静态库不同的是，不需要打包工具（ar、lib.exe），直接使用编译器即可创建动态库。")]),s._v(" "),t("p",[t("strong",[s._v("缺点：")])]),s._v(" "),t("ul",[t("li",[s._v("延时绑定，速度略慢")])])]),s._v(" "),t("li",[t("p",[s._v("创建动态库过程")]),s._v(" "),t("p",[t("strong",[s._v("第一步：生成与位置无关的.o 文件")])]),s._v(" "),t("div",{staticClass:"language-sh line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-sh"}},[t("code",[s._v("gcc -fPIC *.c -I "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("..")]),s._v("/include -c   参数-fPIC表示生成与位置无关代码\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br")])]),t("p",[t("strong",[s._v("第二步：创建动态库")])]),s._v(" "),t("div",{staticClass:"language-sh line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-sh"}},[t("code",[s._v("gcc -shared -o libMyTest.so *.o        参数：-shared 制作动态库 -o：重命名生成的新文件\n"),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("mv")]),s._v(" libMyTest.so "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("..")]),s._v("/lib\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br")])])]),s._v(" "),t("li",[t("p",[s._v("使用动态库")]),s._v(" "),t("div",{staticClass:"language-sh line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-sh"}},[t("code",[s._v("第一种方法：\ngcc + 源文件 + -L 动态库路径 + -l动态库名 + -I头文件目录 + -o 可执行文件名\ngcc main.c -L lib -l MyTest -I include -o app\n./app\n（执行失败，找不到链接库，没有给动态链接器（ld-linux.so.2）指定好动态库 libmytest.so 的路径）\n\n第二种方法：\ngcc + 源文件 + -I头文件 + libxxx.so + -o 可执行文件名\ngcc main.c -I include lib/libMyTest.so -o app\n（执行成功，已经指明了动态库的路径）\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br"),t("span",{staticClass:"line-number"},[s._v("8")]),t("br"),t("span",{staticClass:"line-number"},[s._v("9")]),t("br"),t("span",{staticClass:"line-number"},[s._v("10")]),t("br")])]),t("p",[t("strong",[s._v("如何解决第一种方法中找不到链接库的问题")])]),s._v(" "),t("div",{staticClass:"language-sh line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-sh"}},[t("code",[s._v("使用命令ldd app可以查看当前的链接库情况\n\n第一种方法：\n"),t("span",{pre:!0,attrs:{class:"token builtin class-name"}},[s._v("export")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token assign-left variable"}},[s._v("LD_LIBRARY_PATH")]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v("自定义动态库的路径\n（只能起到临时作用，关闭终端后失效）\nLD_LIBRARY_PATH ： 指定查找共享库（动态链接库）时除了默认路径之外的其他路径，该路径在默认路径之前查找\n\n第二种方法：\n将上述命令写入home目录下的.bashrc文件中，保存后重启终端生效（永久）\n\n第三种方法：\n直接将动态库拷贝到user/lib的系统目录下（强烈不推荐！！）\n\n第四种方法：\n将libmytest.so所在绝对路径追加入到/etc/ld.so.conf文件，使用sudo ldconfig -v 更新\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br"),t("span",{staticClass:"line-number"},[s._v("8")]),t("br"),t("span",{staticClass:"line-number"},[s._v("9")]),t("br"),t("span",{staticClass:"line-number"},[s._v("10")]),t("br"),t("span",{staticClass:"line-number"},[s._v("11")]),t("br"),t("span",{staticClass:"line-number"},[s._v("12")]),t("br"),t("span",{staticClass:"line-number"},[s._v("13")]),t("br"),t("span",{staticClass:"line-number"},[s._v("14")]),t("br"),t("span",{staticClass:"line-number"},[s._v("15")]),t("br")])])])]),s._v(" "),t("h2",{attrs:{id:"参考"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[s._v("#")]),s._v(" 参考")]),s._v(" "),t("p",[t("a",{attrs:{href:"https://blog.csdn.net/qq_21034239/article/details/54382311?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.compare&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.compare",target:"_blank",rel:"noopener noreferrer"}},[s._v("gcc 调试中使用静态连接库和动态链接库以及 - I -l L 含义"),t("OutboundLink")],1)]),s._v(" "),t("p",[t("a",{attrs:{href:"https://www.zhihu.com/question/20484931",target:"_blank",rel:"noopener noreferrer"}},[s._v("Linux 中的动态链接库和静态链接库有什么区别"),t("OutboundLink")],1)]),s._v(" "),t("p",[t("a",{attrs:{href:"https://blog.csdn.net/daidaihema/article/details/80902012",target:"_blank",rel:"noopener noreferrer"}},[s._v("Linux 基础 ——gcc 编译、静态库与动态库（共享库）"),t("OutboundLink")],1)])])}),[],!1,null,null,null);a.default=n.exports}}]);